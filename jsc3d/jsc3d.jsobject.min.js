var JSC3D = JSC3D || {}, document = {};

if (void 0 === window) var window = {};

JSC3D.Viewer = function(e, t) {
this.params = t ? {
SceneUrl: t.SceneUrl || "",
InitRotationX: t.InitRotationX || 0,
InitRotationY: t.InitRotationY || 0,
InitRotationZ: t.InitRotationZ || 0,
ModelColor: t.ModelColor || "#caa618",
BackgroundColor1: t.BackgroundColor1 || "#ffffff",
BackgroundColor2: t.BackgroundColor2 || "#383840",
BackgroundImageUrl: t.BackgroundImageUrl || "",
Background: t.Background || "on",
RenderMode: t.RenderMode || "flat",
Definition: t.Definition || "standard",
FaceCulling: t.FaceCulling || "on",
MipMapping: t.MipMapping || "off",
CreaseAngle: t.CreaseAngle || -180,
SphereMapUrl: t.SphereMapUrl || "",
ProgressBar: t.ProgressBar || "on",
Renderer: t.Renderer || "",
LocalBuffers: t.LocalBuffers || "retain"
} : {
SceneUrl: "",
InitRotationX: 0,
InitRotationY: 0,
InitRotationZ: 0,
ModelColor: "#caa618",
BackgroundColor1: "#ffffff",
BackgroundColor2: "#383840",
BackgroundImageUrl: "",
Background: "on",
RenderMode: "flat",
Definition: "standard",
FaceCulling: "on",
MipMapping: "off",
CreaseAngle: -180,
SphereMapUrl: "",
ProgressBar: "on",
Renderer: "",
LocalBuffers: "retain"
}, this.widget = e, this.ctx2d = null, this.canvasData = null, this.bkgColorBuffer = null, 
this.colorBuffer = null, this.zBuffer = null, this.selectionBuffer = null, this.frameWidth = e.width, 
this.frameHeight = e.height, this.scene = null, this.defaultMaterial = null, this.sphereMap = null, 
this.isLoaded = !1, this.isFailed = !1, this.abortUnfinishedLoadingFn = null, this.needUpdate = !1, 
this.needRepaint = !1, this.initRotX = 0, this.initRotY = 0, this.initRotZ = 0, 
this.zoomFactor = 1, this.panning = [ 0, 0 ], this.rotMatrix = new JSC3D.Matrix3x4(), 
this.transformMatrix = new JSC3D.Matrix3x4(), this.sceneUrl = "", this.modelColor = 13280792, 
this.bkgColor1 = 16777215, this.bkgColor2 = 3684416, this.bkgImageUrl = "", this.bkgImage = null, 
this.isBackgroundOn = !0, this.renderMode = "flat", this.definition = "standard", 
this.isCullingDisabled = !1, this.isMipMappingOn = !1, this.creaseAngle = -180, 
this.sphereMapUrl = "", this.showProgressBar = !0, this.buttonStates = {}, this.keyStates = {}, 
this.mouseX = 0, this.mouseY = 0, this.mouseDownX = -1, this.mouseDownY = -1, this.isTouchHeld = !1, 
this.baseZoomFactor = 1, this.suppressDraggingRotation = !1, this.onloadingstarted = null, 
this.onloadingcomplete = null, this.onloadingprogress = null, this.onloadingaborted = null, 
this.onloadingerror = null, this.onmousedown = null, this.onmouseup = null, this.onmousemove = null, 
this.onmousewheel = null, this.onmouseclick = null, this.beforeupdate = null, this.afterupdate = null, 
this.mouseUsage = "default", this.isDefaultInputHandlerEnabled = !0, this.progressFrame = null, 
this.progressRectangle = null, this.messagePanel = null, this.webglBackend = null;
}, JSC3D.Viewer.prototype.setParameter = function(e, t) {
this.params[e] = t;
}, Canvas.prototype.getImageData = function(e, t, r, i) {
return {
width: r,
height: i,
data: new Uint8ClampedArray(r * i * 4)
};
}, Canvas.prototype.putImageData = function(e, t, r) {
this.clearRect(0, 0, e.width, e.height);
for (var i = 0; i < e.height; i++) for (var s = 0; s < e.width; s++) {
var a = e.data[4 * (i * e.width + s)], o = e.data[4 * (i * e.width + s) + 1], n = e.data[4 * (i * e.width + s) + 2];
this.fillStyle = "rgb(" + a + "," + o + "," + n + ")", this.fillRect(s, i, 1, 1);
}
}, JSC3D.Viewer.prototype.init = function() {
switch (this.sceneUrl = this.params.SceneUrl, this.initRotX = parseFloat(this.params.InitRotationX), 
this.initRotY = parseFloat(this.params.InitRotationY), this.initRotZ = parseFloat(this.params.InitRotationZ), 
this.modelColor = parseInt("0x" + this.params.ModelColor.substring(1)), this.bkgColor1 = parseInt("0x" + this.params.BackgroundColor1.substring(1)), 
this.bkgColor2 = parseInt("0x" + this.params.BackgroundColor2.substring(1)), this.bkgImageUrl = this.params.BackgroundImageUrl, 
this.isBackgroundOn = "on" == this.params.Background.toLowerCase(), this.renderMode = this.params.RenderMode.toLowerCase(), 
this.definition = this.params.Definition.toLowerCase(), this.isCullingDisabled = "off" == this.params.FaceCulling.toLowerCase(), 
this.creaseAngle = parseFloat(this.params.CreaseAngle), this.isMipMappingOn = "on" == this.params.MipMapping.toLowerCase(), 
this.sphereMapUrl = this.params.SphereMapUrl, this.showProgressBar = "on" == this.params.ProgressBar.toLowerCase(), 
this.useWebGL = "webgl" == this.params.Renderer.toLowerCase(), this.releaseLocalBuffers = "release" == this.params.LocalBuffers.toLowerCase(), 
this.ctx2d = new Canvas(), this.widget.add(this.ctx2d), this.canvasData = this.ctx2d.getImageData(0, 0, this.widget.width, this.widget.height), 
(this.widget.width <= 2 || this.widget.height <= 2) && (this.definition = "standard"), 
this.definition) {
case "low":
this.frameWidth = ~~((this.widget.width + 1) / 2), this.frameHeight = ~~((this.widget.height + 1) / 2);
break;

case "high":
this.frameWidth = 2 * this.widget.width, this.frameHeight = 2 * this.widget.height;
break;

case "standard":
default:
this.frameWidth = this.widget.width, this.frameHeight = this.widget.height;
}
this.zoomFactor = 1, this.panning = [ 0, 0 ], this.rotMatrix.identity(), this.transformMatrix.identity(), 
this.isLoaded = !1, this.isFailed = !1, this.needUpdate = !1, this.needRepaint = !1, 
this.scene = null, this.defaultMaterial = new JSC3D.Material("default", void 0, this.modelColor, 0, !0), 
this.webglBackend || (this.colorBuffer = new Array(this.frameWidth * this.frameHeight), 
this.zBuffer = new Array(this.frameWidth * this.frameHeight), this.selectionBuffer = new Array(this.frameWidth * this.frameHeight), 
this.bkgColorBuffer = new Array(this.frameWidth * this.frameHeight)), this.generateBackground(), 
this.drawBackground();
var e = this;
!function t() {
e.doUpdate(), setTimeout(t, 30);
}(), this.setBackgroudImageFromUrl(this.bkgImageUrl), this.loadScene(), this.setSphereMapFromUrl(this.sphereMapUrl);
}, JSC3D.Viewer.prototype.update = function(e) {
this.isFailed || (e ? this.needRepaint = !0 : this.needUpdate = !0);
}, JSC3D.Viewer.prototype.rotate = function(e, t, r) {
this.rotMatrix.rotateAboutXAxis(e), this.rotMatrix.rotateAboutYAxis(t), this.rotMatrix.rotateAboutZAxis(r);
}, JSC3D.Viewer.prototype.setRenderMode = function(e) {
this.params.RenderMode = e, this.renderMode = e;
}, JSC3D.Viewer.prototype.setDefinition = function(e) {
if ((this.widget.width <= 2 || this.widget.height <= 2) && (e = "standard"), e != this.definition) {
this.params.Definition = e, this.definition = e;
var t = this.frameWidth;
switch (this.definition) {
case "low":
this.frameWidth = ~~((this.widget.width + 1) / 2), this.frameHeight = ~~((this.widget.height + 1) / 2);
break;

case "high":
this.frameWidth = 2 * this.widget.width, this.frameHeight = 2 * this.widget.height;
break;

case "standard":
default:
this.frameWidth = this.widget.width, this.frameHeight = this.widget.height;
}
var r = this.frameWidth / t;
if (this.zoomFactor *= r, this.panning[0] *= r, this.panning[1] *= r, !this.webglBackend) {
var i = this.frameWidth * this.frameHeight;
this.colorBuffer.length < i && (this.colorBuffer = new Array(i)), this.zBuffer.length < i && (this.zBuffer = new Array(i)), 
this.selectionBuffer.length < i && (this.selectionBuffer = new Array(i)), this.bkgColorBuffer.length < i && (this.bkgColorBuffer = new Array(i)), 
this.generateBackground();
}
}
}, JSC3D.Viewer.prototype.setBackgroudImageFromUrl = function(e) {
if (this.params.BackgroundImageUrl = e, this.bkgImageUrl = e, "" != e) {
var t = this, r = new Image();
r.onload = function() {
t.bkgImage = this, t.generateBackground();
}, r.crossOrigin = "anonymous", r.src = encodeURI(e);
} else this.bkgImage = null;
}, JSC3D.Viewer.prototype.setSphereMapFromUrl = function(e) {
if (this.params.SphereMapUrl = e, this.sphereMapUrl = e, "" != e) {
var t = this, r = new JSC3D.Texture();
r.onready = function() {
t.sphereMap = r, t.update();
}, r.createFromUrl(this.sphereMapUrl);
} else this.sphereMap = null;
}, JSC3D.Viewer.prototype.enableDefaultInputHandler = function(e) {
this.isDefaultInputHandlerEnabled = e;
}, JSC3D.Viewer.prototype.setMouseUsage = function(e) {
this.mouseUsage = e;
}, JSC3D.Viewer.prototype.isWebGLEnabled = function() {
return null != this.webglBackend;
}, JSC3D.Viewer.prototype.replaceSceneFromUrl = function(e) {
this.params.SceneUrl = e, this.sceneUrl = e, this.isFailed = this.isLoaded = !1, 
this.loadScene();
}, JSC3D.Viewer.prototype.replaceScene = function(e) {
this.params.SceneUrl = "", this.sceneUrl = "", this.isFailed = !1, this.isLoaded = !0, 
this.setupScene(e);
}, JSC3D.Viewer.prototype.resetScene = function() {
var e = !this.scene || this.scene.isEmpty() ? 0 : this.scene.aabb.lengthOfDiagonal();
this.zoomFactor = 0 == e ? 1 : (this.frameWidth < this.frameHeight ? this.frameWidth : this.frameHeight) / e, 
this.panning = [ 0, 0 ], this.rotMatrix.identity(), this.rotMatrix.rotateAboutXAxis(this.initRotX), 
this.rotMatrix.rotateAboutYAxis(this.initRotY), this.rotMatrix.rotateAboutZAxis(this.initRotZ);
}, JSC3D.Viewer.prototype.getScene = function() {
return this.scene;
}, JSC3D.Viewer.prototype.pick = function(e, t) {
var r = new JSC3D.PickInfo(), i = this.widget.getBoundingClientRect(), s = e - i.left, a = t - i.top;
r.canvasX = s, r.canvasY = a;
var o = 0;
if (this.webglBackend) o = this.webglBackend.pick(s, a); else {
var n = s, h = a;
if (null != this.selectionBuffer && s >= 0 && s < this.widget.width && a >= 0 && a < this.widget.height) {
switch (this.definition) {
case "low":
n = ~~(n / 2), h = ~~(h / 2);
break;

case "high":
n *= 2, h *= 2;
}
(o = this.selectionBuffer[h * this.frameWidth + n]) > 0 && (r.depth = this.zBuffer[h * this.frameWidth + n]);
}
}
if (o > 0) for (var l = this.scene.getChildren(), f = 0; f < l.length; f++) if (l[f].internalId == o) {
r.mesh = l[f];
break;
}
return r;
}, JSC3D.Viewer.prototype.doUpdate = function() {
(this.needUpdate || this.needRepaint) && (null != this.beforeupdate && "function" == typeof this.beforeupdate && this.beforeupdate(), 
this.scene ? (this.needUpdate && (this.beginScene(), this.render(), this.endScene()), 
this.paint()) : this.drawBackground(), this.needRepaint = !1, this.needUpdate = !1, 
null != this.afterupdate && "function" == typeof this.afterupdate && this.afterupdate());
}, JSC3D.Viewer.prototype.paint = function() {
!this.webglBackend && this.ctx2d && this.ctx2d.putImageData(this.canvasData, 0, 0);
}, JSC3D.Viewer.prototype.mouseDownHandler = function(e) {
if (this.isLoaded) {
if (this.onmousedown) {
var t = this.pick(e.clientX, e.clientY);
this.onmousedown(t.canvasX, t.canvasY, e.button, t.depth, t.mesh);
}
e.preventDefault(), e.stopPropagation(), this.isDefaultInputHandlerEnabled && (this.buttonStates[e.button] = !0, 
this.mouseX = e.clientX, this.mouseY = e.clientY, this.mouseDownX = e.clientX, this.mouseDownY = e.clientY);
}
}, JSC3D.Viewer.prototype.mouseUpHandler = function(e) {
var t;
this.isLoaded && ((this.onmouseup || this.onmouseclick) && (t = this.pick(e.clientX, e.clientY)), 
this.onmouseup && this.onmouseup(t.canvasX, t.canvasY, e.button, t.depth, t.mesh), 
this.onmouseclick && this.mouseDownX == e.clientX && this.mouseDownY == e.clientY && (this.onmouseclick(t.canvasX, t.canvasY, e.button, t.depth, t.mesh), 
this.mouseDownX = -1, this.mouseDownY = -1), e.preventDefault(), e.stopPropagation(), 
this.isDefaultInputHandlerEnabled && (this.buttonStates[e.button] = !1));
}, JSC3D.Viewer.prototype.mouseMoveHandler = function(e) {
if (this.isLoaded) {
if (this.onmousemove) {
var t = this.pick(e.clientX, e.clientY);
this.onmousemove(t.canvasX, t.canvasY, e.button, t.depth, t.mesh);
}
if (e.preventDefault(), e.stopPropagation(), this.isDefaultInputHandlerEnabled) {
var r = 1 == this.buttonStates[0], i = 1 == this.keyStates[16], s = 1 == this.keyStates[17];
if (r) {
if (i && "default" == this.mouseUsage || "zoom" == this.mouseUsage) this.zoomFactor *= this.mouseY <= e.clientY ? 1.04 : .96; else if (s && "default" == this.mouseUsage || "pan" == this.mouseUsage) {
var a = "low" == this.definition ? .5 : "high" == this.definition ? 2 : 1;
this.panning[0] += a * (e.clientX - this.mouseX), this.panning[1] += a * (e.clientY - this.mouseY);
} else if ("default" == this.mouseUsage || "rotate" == this.mouseUsage) {
var o = 360 * (e.clientY - this.mouseY) / this.widget.width, n = 360 * (e.clientX - this.mouseX) / this.widget.height;
this.rotMatrix.rotateAboutXAxis(o), this.rotMatrix.rotateAboutYAxis(n);
}
this.mouseX = e.clientX, this.mouseY = e.clientY, this.mouseDownX = -1, this.mouseDownY = -1, 
this.update();
}
}
}
}, JSC3D.Viewer.prototype.mouseWheelHandler = function(e) {
if (this.isLoaded) {
if (this.onmousewheel) {
var t = this.pick(e.clientX, e.clientY);
this.onmousewheel(t.canvasX, t.canvasY, e.button, t.depth, t.mesh);
}
e.preventDefault(), e.stopPropagation(), this.isDefaultInputHandlerEnabled && (this.mouseDownX = -1, 
this.mouseDownY = -1, this.zoomFactor *= ("firefox" == JSC3D.PlatformInfo.browser ? -e.detail : e.wheelDelta) < 0 ? 1.1 : .91, 
this.update());
}
}, JSC3D.Viewer.prototype.touchStartHandler = function(e) {
if (this.isLoaded && e.touches.length > 0) {
var t = e.touches[0].clientX, r = e.touches[0].clientY;
if (this.onmousedown) {
var i = this.pick(t, r);
this.onmousedown(i.canvasX, i.canvasY, 0, i.depth, i.mesh);
}
if (e.preventDefault(), e.stopPropagation(), !this.isDefaultInputHandlerEnabled) return;
this.buttonStates[0] = !0, this.mouseX = t, this.mouseY = r, this.mouseDownX = t, 
this.mouseDownY = r;
}
}, JSC3D.Viewer.prototype.touchEndHandler = function(e) {
var t;
this.isLoaded && ((this.onmouseup || this.onmouseclick) && (t = this.pick(this.mouseX, this.mouseY)), 
this.onmouseup && this.onmouseup(t.canvasX, t.canvasY, 0, t.depth, t.mesh), this.onmouseclick && this.mouseDownX == e.touches[0].clientX && this.mouseDownY == e.touches[0].clientY && (this.onmouseclick(t.canvasX, t.canvasY, 0, t.depth, t.mesh), 
this.mouseDownX = -1, this.mouseDownY = -1), e.preventDefault(), e.stopPropagation(), 
this.isDefaultInputHandlerEnabled && (this.buttonStates[0] = !1));
}, JSC3D.Viewer.prototype.touchMoveHandler = function(e) {
if (this.isLoaded && e.touches.length > 0) {
var t = e.touches[0].clientX, r = e.touches[0].clientY;
if (this.onmousemove) {
var i = this.pick(t, r);
this.onmousemove(i.canvasX, i.canvasY, 0, i.depth, i.mesh);
}
if (e.preventDefault(), e.stopPropagation(), !this.isDefaultInputHandlerEnabled) return;
if ("zoom" == this.mouseUsage) this.zoomFactor *= this.mouseY <= r ? 1.04 : .96; else if ("pan" == this.mouseUsage) {
var s = "low" == this.definition ? .5 : "high" == this.definition ? 2 : 1;
this.panning[0] += s * (t - this.mouseX), this.panning[1] += s * (r - this.mouseY);
} else if ("default" == this.mouseUsage || "rotate" == this.mouseUsage) {
var a = 360 * (r - this.mouseY) / this.widget.width, o = 360 * (t - this.mouseX) / this.widget.height;
this.rotMatrix.rotateAboutXAxis(a), this.rotMatrix.rotateAboutYAxis(o);
}
this.mouseX = t, this.mouseY = r, this.mouseDownX = -1, this.mouseDownY = -1, this.update();
}
}, JSC3D.Viewer.prototype.keyDownHandler = function(e) {
this.isDefaultInputHandlerEnabled && (this.keyStates[e.keyCode] = !0);
}, JSC3D.Viewer.prototype.keyUpHandler = function(e) {
this.isDefaultInputHandlerEnabled && (this.keyStates[e.keyCode] = !1);
}, JSC3D.Viewer.prototype.gestureHandler = function(e) {
if (this.isLoaded) {
var t = e.gesture.center.pageX - document.body.scrollLeft, r = e.gesture.center.pageY - document.body.scrollTop, i = this.pick(t, r);
switch (e.type) {
case "touch":
this.onmousedown && this.onmousedown(i.canvasX, i.canvasY, 0, i.depth, i.mesh), 
this.baseZoomFactor = this.zoomFactor, this.mouseX = t, this.mouseY = r, this.mouseDownX = t, 
this.mouseDownY = r;
break;

case "release":
this.onmouseup && this.onmouseup(i.canvasX, i.canvasY, 0, i.depth, i.mesh), this.onmouseclick && this.mouseDownX == t && this.mouseDownY == r && this.onmouseclick(i.canvasX, i.canvasY, 0, i.depth, i.mesh), 
this.mouseDownX = -1, this.mouseDownY = -1, this.isTouchHeld = !1;
break;

case "hold":
this.isTouchHeld = !0, this.mouseDownX = -1, this.mouseDownY = -1;
break;

case "drag":
if (this.onmousemove && this.onmousemove(i.canvasX, i.canvasY, 0, i.depth, i.mesh), 
!this.isDefaultInputHandlerEnabled) break;
if (this.isTouchHeld) {
var s = "low" == this.definition ? .5 : "high" == this.definition ? 2 : 1;
this.panning[0] += s * (t - this.mouseX), this.panning[1] += s * (r - this.mouseY);
} else if (!this.suppressDraggingRotation) {
var a = 360 * (r - this.mouseY) / this.widget.width, o = 360 * (t - this.mouseX) / this.widget.height;
this.rotMatrix.rotateAboutXAxis(a), this.rotMatrix.rotateAboutYAxis(o);
}
this.mouseX = t, this.mouseY = r, this.mouseDownX = -1, this.mouseDownY = -1, this.update();
break;

case "pinch":
if (this.onmousewheel && this.onmousewheel(i.canvasX, i.canvasY, 0, i.depth, i.mesh), 
!this.isDefaultInputHandlerEnabled) break;
this.suppressDraggingRotation = !0, this.zoomFactor = this.baseZoomFactor * e.gesture.scale, 
this.mouseDownX = -1, this.mouseDownY = -1, this.update();
break;

case "transformend":
var n = this;
setTimeout(function() {
n.suppressDraggingRotation = !1;
}, 250);
}
e.gesture.preventDefault(), e.gesture.stopPropagation();
}
}, JSC3D.Viewer.prototype.loadScene = function() {
if (this.abortUnfinishedLoadingFn && this.abortUnfinishedLoadingFn(), this.scene = null, 
this.isLoaded = !1, this.update(), "" == this.sceneUrl) return !1;
var e = this.sceneUrl.indexOf("?"), t = -1 == e ? this.sceneUrl : this.sceneUrl.substring(0, e), r = t.lastIndexOf("/");
-1 == r && (r = t.lastIndexOf("\\"));
var i = t.substring(r + 1), s = i.lastIndexOf(".");
if (-1 == s) return JSC3D.console && JSC3D.console.logError("Cannot get file format for the lack of file extension."), 
!1;
var a = i.substring(s + 1), o = JSC3D.LoaderSelector.getLoader(a);
if (!o) return JSC3D.console && JSC3D.console.logError('Unsupported file format: "' + a + '".'), 
!1;
var n = this;
return o.onload = function(e) {
n.abortUnfinishedLoadingFn = null, n.setupScene(e), n.onloadingcomplete && "function" == typeof n.onloadingcomplete && n.onloadingcomplete();
}, o.onerror = function(e) {
n.scene = null, n.isLoaded = !1, n.isFailed = !0, n.abortUnfinishedLoadingFn = null, 
n.update(), n.reportError(e), n.onloadingerror && "function" == typeof n.onloadingerror && n.onloadingerror(e);
}, o.onprogress = function(e, t) {
n.showProgressBar && n.reportProgress(e, t), n.onloadingprogress && "function" == typeof n.onloadingprogress && n.onloadingprogress(e, t);
}, o.onresource = function(e) {
e instanceof JSC3D.Texture && n.isMipMappingOn && !e.hasMipmap() && e.generateMipmaps(), 
n.update();
}, this.abortUnfinishedLoadingFn = function() {
o.abort(), n.abortUnfinishedLoadingFn = null, n.hideProgress(), n.onloadingaborted && "function" == typeof n.onloadingaborted && n.onloadingaborted();
}, o.loadFromUrl(this.sceneUrl), this.onloadingstarted && "function" == typeof this.onloadingstarted && this.onloadingstarted(), 
!0;
}, JSC3D.Viewer.prototype.setupScene = function(e) {
if (this.creaseAngle >= 0) {
var t = this.creaseAngle;
e.forEachChild(function(e) {
e.creaseAngle = t;
});
}
if (e.init(), !e.isEmpty()) {
var r = e.aabb.lengthOfDiagonal(), i = this.frameWidth, s = this.frameHeight;
this.zoomFactor = 0 == r ? 1 : (i < s ? i : s) / r, this.panning = [ 0, 0 ];
}
this.rotMatrix.identity(), this.rotMatrix.rotateAboutXAxis(this.initRotX), this.rotMatrix.rotateAboutYAxis(this.initRotY), 
this.rotMatrix.rotateAboutZAxis(this.initRotZ), this.scene = e, this.isLoaded = !0, 
this.isFailed = !1, this.needUpdate = !1, this.needRepaint = !1, this.update(), 
this.hideProgress(), this.hideError();
}, JSC3D.Viewer.prototype.reportProgress = function(e, t) {
if (!this.progressFrame) {
var r = this.widget.getBoundingClientRect(), i = "rgb(" + (255 - ((16711680 & this.bkgColor1) >> 16)) + "," + (255 - ((65280 & this.bkgColor1) >> 8)) + "," + (255 - (255 & this.bkgColor1)) + ")", s = window.pageXOffset + r.left + 40, a = window.pageYOffset + r.top + .38 * r.height, o = r.width - 2 * (s - r.left);
this.progressFrame = document.createElement("div"), this.progressFrame.style.position = "absolute", 
this.progressFrame.style.left = s + "px", this.progressFrame.style.top = a + "px", 
this.progressFrame.style.width = o + "px", this.progressFrame.style.height = "20px", 
this.progressFrame.style.border = "1px solid " + i, this.progressFrame.style.pointerEvents = "none", 
document.body.appendChild(this.progressFrame), this.progressRectangle = document.createElement("div"), 
this.progressRectangle.style.position = "absolute", this.progressRectangle.style.left = s + 3 + "px", 
this.progressRectangle.style.top = a + 3 + "px", this.progressRectangle.style.width = "0px", 
this.progressRectangle.style.height = "16px", this.progressRectangle.style.background = i, 
this.progressRectangle.style.pointerEvents = "none", document.body.appendChild(this.progressRectangle), 
this.messagePanel || (this.messagePanel = document.createElement("div"), this.messagePanel.style.position = "absolute", 
this.messagePanel.style.left = s + "px", this.messagePanel.style.top = a - 16 + "px", 
this.messagePanel.style.width = o + "px", this.messagePanel.style.height = "14px", 
this.messagePanel.style.font = "bold 14px Courier New", this.messagePanel.style.color = i, 
this.messagePanel.style.pointerEvents = "none", document.body.appendChild(this.messagePanel));
}
"block" != this.progressFrame.style.display && (this.progressFrame.style.display = "block", 
this.progressRectangle.style.display = "block"), e && "block" != this.messagePanel.style.display && (this.messagePanel.style.display = "block"), 
this.progressRectangle.style.width = (parseFloat(this.progressFrame.style.width) - 4) * t + "px", 
this.messagePanel.innerHTML = e;
}, JSC3D.Viewer.prototype.hideProgress = function() {
this.progressFrame && (this.messagePanel.style.display = "none", this.progressFrame.style.display = "none", 
this.progressRectangle.style.display = "none");
}, JSC3D.Viewer.prototype.reportError = function(e) {
if (!this.messagePanel) {
var t = this.widget.getBoundingClientRect(), r = "rgb(" + (255 - ((16711680 & this.bkgColor1) >> 16)) + "," + (255 - ((65280 & this.bkgColor1) >> 8)) + "," + (255 - (255 & this.bkgColor1)) + ")", i = window.pageXOffset + t.left + 40, s = window.pageYOffset + t.top + .38 * t.height, a = t.width - 2 * (i - t.left);
this.messagePanel = document.createElement("div"), this.messagePanel.style.position = "absolute", 
this.messagePanel.style.left = i + "px", this.messagePanel.style.top = s - 16 + "px", 
this.messagePanel.style.width = a + "px", this.messagePanel.style.height = "14px", 
this.messagePanel.style.font = "bold 14px Courier New", this.messagePanel.style.color = r, 
this.messagePanel.style.pointerEvents = "none", document.body.appendChild(this.messagePanel);
}
"none" != this.progressFrame.style.display && (this.progressFrame.style.display = "none", 
this.progressRectangle.style.display = "none"), e && "block" != this.messagePanel.style.display && (this.messagePanel.style.display = "block"), 
this.messagePanel.innerHTML = e;
}, JSC3D.Viewer.prototype.hideError = function() {
this.messagePanel && (this.messagePanel.style.display = "none");
}, JSC3D.Viewer.prototype.generateBackground = function() {
this.webglBackend ? this.bkgImage ? this.webglBackend.setBackgroundImage(this.bkgImage) : this.webglBackend.setBackgroundColors(this.bkgColor1, this.bkgColor2) : this.bkgImage ? this.fillBackgroundWithImage() : this.fillGradientBackground();
}, JSC3D.Viewer.prototype.fillGradientBackground = function() {
for (var e = this.frameWidth, t = this.frameHeight, r = this.bkgColorBuffer, i = (16711680 & this.bkgColor1) >> 16, s = (65280 & this.bkgColor1) >> 8, a = 255 & this.bkgColor1, o = (16711680 & this.bkgColor2) >> 16, n = (65280 & this.bkgColor2) >> 8, h = 255 & this.bkgColor2, l = this.isBackgroundOn ? 4278190080 : 0, f = 0, u = 0; u < t; u++) for (var d = i + u * (o - i) / t & 255, p = s + u * (n - s) / t & 255, m = a + u * (h - a) / t & 255, c = 0; c < e; c++) r[f++] = l | d << 16 | p << 8 | m;
}, JSC3D.Viewer.prototype.fillBackgroundWithImage = function() {
var e = this.frameWidth, t = this.frameHeight;
if (!(this.bkgImage.width <= 0 || this.bkgImage.height <= 0)) {
var r = !1, i = JSC3D.Texture.cv;
if (!canvas) try {
i = this.widget, JSC3D.Texture.cv = i, r = !0;
} catch (e) {
return;
}
i.width == e && i.height == t || (i.width = e, i.height = t, r = !0);
var s = null;
try {
var a = new Canvas();
i.add(a), r || a.clearRect(0, 0, e, t), a.drawImage(this.bkgImage, 0, 0, e, t), 
s = a.getImageData(0, 0, e, t).data;
} catch (e) {
return;
}
for (var o = this.bkgColorBuffer, n = e * t, h = this.isBackgroundOn ? 4278190080 : 0, l = 0, f = 0; l < n; l++, 
f += 4) o[l] = h | s[f] << 16 | s[f + 1] << 8 | s[f + 2];
}
}, JSC3D.Viewer.prototype.drawBackground = function() {
(this.webglBackend || this.ctx2d) && (this.beginScene(), this.endScene(), this.paint());
}, JSC3D.Viewer.prototype.beginScene = function() {
if (this.webglBackend) this.webglBackend.beginFrame(this.definition, this.isBackgroundOn); else for (var e = this.colorBuffer, t = this.zBuffer, r = this.selectionBuffer, i = this.bkgColorBuffer, s = this.frameWidth * this.frameHeight, a = 0; a < s; a++) e[a] = i[a], 
t[a] = -1 / 0, r[a] = 0;
}, JSC3D.Viewer.prototype.endScene = function() {
if (this.webglBackend) this.webglBackend.endFrame(); else {
var e = this.canvasData.data, t = this.widget.width, r = this.widget.height, i = this.colorBuffer, s = this.frameWidth, a = s * this.frameHeight;
switch (this.definition) {
case "low":
for (var o = t >> 1, n = s - o, h = 0, l = 0, f = 0; f < r; f++) {
for (var u = 0; u < t; u++) {
var d = i[h];
e[l] = (16711680 & d) >> 16, e[l + 1] = (65280 & d) >> 8, e[l + 2] = 255 & d, e[l + 3] = d >>> 24, 
h += 1 & u, l += 4;
}
h += 1 & f ? n : -o;
}
break;

case "high":
for (h = 0, l = 0, f = 0; f < r; f++) {
for (u = 0; u < t; u++) {
var p = i[h], m = i[h + 1], c = i[h + s], g = i[h + s + 1];
e[l] = (16711680 & p) + (16711680 & m) + (16711680 & c) + (16711680 & g) >> 18, 
e[l + 1] = (65280 & p) + (65280 & m) + (65280 & c) + (65280 & g) >> 10, e[l + 2] = (255 & p) + (255 & m) + (255 & c) + (255 & g) >> 2, 
e[l + 3] = p >>> 24, h += 2, l += 4;
}
h += s;
}
break;

case "standard":
default:
for (h = 0, l = 0; h < a; h++, l += 4) {
d = i[h];
e[l] = (16711680 & d) >> 16, e[l + 1] = (65280 & d) >> 8, e[l + 2] = 255 & d, e[l + 3] = d >>> 24;
}
}
}
}, JSC3D.Viewer.prototype.render = function() {
if (!this.scene.isEmpty()) {
var e = this.scene.aabb;
if (this.webglBackend) {
var t = this.frameWidth, r = this.frameHeight, i = e.lengthOfDiagonal();
this.transformMatrix.identity(), this.transformMatrix.translate(-.5 * (e.minX + e.maxX), -.5 * (e.minY + e.maxY), -.5 * (e.minZ + e.maxZ)), 
this.transformMatrix.multiply(this.rotMatrix), this.transformMatrix.scale(2 * this.zoomFactor / t, 2 * this.zoomFactor / r, -2 / i), 
this.transformMatrix.translate(2 * this.panning[0] / t, -2 * this.panning[1] / r, 0);
} else this.transformMatrix.identity(), this.transformMatrix.translate(-.5 * (e.minX + e.maxX), -.5 * (e.minY + e.maxY), -.5 * (e.minZ + e.maxZ)), 
this.transformMatrix.multiply(this.rotMatrix), this.transformMatrix.scale(this.zoomFactor, -this.zoomFactor, this.zoomFactor), 
this.transformMatrix.translate(.5 * this.frameWidth + this.panning[0], .5 * this.frameHeight + this.panning[1], 0);
var s = this.sortScene(this.transformMatrix);
if (this.webglBackend) this.webglBackend.render(this.scene.getChildren(), this.transformMatrix, this.rotMatrix, this.renderMode, this.defaultMaterial, this.sphereMap, this.isCullingDisabled); else for (var a = 0; a < s.length; a++) {
var o = s[a];
if (!o.isTrivial() && (JSC3D.Math3D.transformVectors(this.transformMatrix, o.vertexBuffer, o.transformedVertexBuffer), 
o.visible)) switch (o.renderMode || this.renderMode) {
case "point":
this.renderPoint(o);
break;

case "wireframe":
this.renderWireframe(o);
break;

case "flat":
this.renderSolidFlat(o);
break;

case "smooth":
this.renderSolidSmooth(o);
break;

case "texture":
o.hasTexture() ? this.renderSolidTexture(o) : this.renderSolidFlat(o);
break;

case "textureflat":
o.hasTexture() ? this.renderTextureFlat(o) : this.renderSolidFlat(o);
break;

case "texturesmooth":
o.isEnvironmentCast && null != this.sphereMap && this.sphereMap.hasData() ? this.renderSolidSphereMapped(o) : o.hasTexture() ? this.renderTextureSmooth(o) : this.renderSolidSmooth(o);
break;

default:
this.renderSolidFlat(o);
}
}
}
}, JSC3D.Viewer.prototype.sortScene = function(e) {
for (var t = [], r = this.scene.getChildren(), i = 0; i < r.length; i++) {
var s = r[i];
if (!s.isTrivial()) {
t.push(s);
var a = s.aabb.center();
JSC3D.Math3D.transformVectors(e, a, a);
var o = s.material ? s.material : this.defaultMaterial;
s.sortKey = {
depth: a[2],
isTransparnt: o.transparency > 0 || !!s.hasTexture() && s.texture.hasTransparency
};
}
}
return t.sort(function(e, t) {
return !e.sortKey.isTransparnt && t.sortKey.isTransparnt ? -1 : e.sortKey.isTransparnt && !t.sortKey.isTransparnt ? 1 : e.sortKey.isTransparnt ? e.sortKey.depth - t.sortKey.depth : t.sortKey.depth - e.sortKey.depth;
}), t;
}, JSC3D.Viewer.prototype.renderPoint = function(e) {
for (var t = this.frameWidth, r = t - 1, i = this.frameHeight - 1, s = (e.indexBuffer, 
e.transformedVertexBuffer), a = this.colorBuffer, o = this.zBuffer, n = this.selectionBuffer, h = s.length / 3, l = e.internalId, f = 4278190080 | (e.material ? e.material.diffuseColor : this.defaultMaterial.diffuseColor), u = 0, d = 0; u < h; u++, 
d += 3) {
var p = ~~(s[d] + .5), m = ~~(s[d + 1] + .5), c = s[d + 2];
if (p >= 0 && p < r && m >= 0 && m < i) {
var g = m * t + p;
c > o[g] && (o[g] = c, a[g] = f, n[g] = l), c > o[++g] && (o[g] = c, a[g] = f, n[g] = l), 
c > o[g += r] && (o[g] = c, a[g] = f, n[g] = l), c > o[++g] && (o[g] = c, a[g] = f, 
n[g] = l);
}
}
}, JSC3D.Viewer.prototype.renderWireframe = function(e) {
var t = this.frameWidth, r = t - 1, i = this.frameHeight - 1, s = e.indexBuffer, a = e.transformedVertexBuffer, o = e.transformedFaceNormalZBuffer, n = this.colorBuffer, h = this.zBuffer, l = this.selectionBuffer, f = e.faceCount, u = e.internalId, d = 4278190080 | (e.material ? e.material.diffuseColor : this.defaultMaterial.diffuseColor), p = e.isDoubleSided || this.isCullingDisabled;
(!o || o.length < f) && (e.transformedFaceNormalZBuffer = new Array(f), o = e.transformedFaceNormalZBuffer), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, o);
for (var m = 0, c = 0; m < f; ) {
var g = o[m++];
if (p && (g = g > 0 ? g : -g), g < 0) do {} while (-1 != s[c++]); else {
var C, y, S;
y = 3 * s[c++], S = 3 * s[c++], C = y;
for (var x = !1; !x; ) {
var D, v, w, b, B = ~~(a[y] + .5), J = ~~(a[y + 1] + .5), M = a[y + 2], k = ~~(a[S] + .5), F = ~~(a[S + 1] + .5), I = a[S + 2], V = k - B, A = F - J, N = I - M;
Math.abs(V) > Math.abs(A) ? (D = V, v = V > 0 ? 1 : -1, w = 0 != V ? v * A / V : 0, 
b = 0 != V ? v * N / V : 0) : (D = A, w = A > 0 ? 1 : -1, v = 0 != A ? w * V / A : 0, 
b = 0 != A ? w * N / A : 0);
var X = B, U = J, Y = M;
D < 0 && (X = k, U = F, Y = I, D = -D, v = -v, w = -w, b = -b);
for (var L = 0; L < D; L++) {
if (X >= 0 && X < r && U >= 0 && U < i) {
var T = ~~U * t + ~~X;
Y > h[T] && (h[T] = Y, n[T] = d, l[T] = u);
}
X += v, U += w, Y += b;
}
S == C ? x = !0 : (y = S, S = -1 != s[c] ? 3 * s[c++] : C);
}
c++;
}
}
}, JSC3D.Viewer.prototype.renderSolidFlat = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedFaceNormalZBuffer, o = this.colorBuffer, n = this.zBuffer, h = this.selectionBuffer, l = e.faceCount, f = e.internalId, u = e.material ? e.material : this.defaultMaterial, d = u.getPalette(), p = 0 == u.transparency, m = ~~(255 * u.transparency), c = 255 - m, g = e.isDoubleSided || this.isCullingDisabled;
if (1 != u.transparency) {
(!a || a.length < l) && (e.transformedFaceNormalZBuffer = new Array(l), a = e.transformedFaceNormalZBuffer), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, a);
for (var C = new Array(3), y = new Array(3), S = new Array(3), x = 0, D = 0; x < l; ) {
var v = a[x++];
if (g && (v = v > 0 ? v : -v), v < 0) do {} while (-1 != i[D++]); else {
var w, b, B, J = 4278190080 | d[~~(255 * v)];
w = 3 * i[D++], b = 3 * i[D++];
do {
B = 3 * i[D++], C[0] = ~~(s[w] + .5), y[0] = ~~(s[w + 1] + .5), S[0] = s[w + 2], 
C[1] = ~~(s[b] + .5), y[1] = ~~(s[b + 1] + .5), S[1] = s[b + 2], C[2] = ~~(s[B] + .5), 
y[2] = ~~(s[B + 1] + .5), S[2] = s[B + 2];
var M = y[0] < y[1] ? 0 : 1;
M = y[M] < y[2] ? M : 2;
var k = y[0] > y[1] ? 0 : 1, F = 3 - (k = y[k] > y[2] ? k : 2) - M;
if (M != k) {
var I = C[k], V = S[k], A = y[k] - y[M];
A = 0 != A ? A : 1;
var N = (C[k] - C[M]) / A, X = (S[k] - S[M]) / A, U = C[k], Y = S[k], L = y[k] - y[F];
L = 0 != L ? L : 1;
var T = (C[k] - C[F]) / L, R = (S[k] - S[F]) / L, P = C[F], Z = S[F], H = y[F] - y[M];
H = 0 != H ? H : 1;
for (var E = (C[F] - C[M]) / H, O = (S[F] - S[M]) / H, z = y[k] * t, W = y[k]; W > y[M]; W--) {
if (W >= 0 && W < r) {
var q, j, K, G = ~~I, _ = V;
if (W > y[F] ? (q = ~~U, j = Y) : (q = ~~P, j = Z), G > q) K = G, G = q, q = K, 
K = _, _ = j, j = K;
G < 0 && (G = 0), q >= t && (q = t - 1);
var Q = G != q ? (j - _) / (q - G) : 1, $ = z + G;
if (p) for (var ee = G, te = _; ee <= q; ee++, te += Q) te > n[$] && (n[$] = te, 
o[$] = J, h[$] = f), $++; else for (ee = G, te = _; ee < q; ee++, te += Q) {
if (te > n[$]) {
var re = J, ie = o[$], se = (16711680 & ie) * m + (16711680 & re) * c >> 8, ae = (65280 & ie) * m + (65280 & re) * c >> 8, oe = (255 & ie) * m + (255 & re) * c >> 8, ne = 4278190080 & ie | c << 24;
o[$] = ne | 16711680 & se | 65280 & ae | 255 & oe, h[$] = f;
}
$++;
}
}
I -= N, V -= X, W > y[F] ? (U -= T, Y -= R) : (P -= E, Z -= O), z -= t;
}
}
b = B;
} while (-1 != i[D]);
D++;
}
}
}
}, JSC3D.Viewer.prototype.renderSolidSmooth = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedVertexNormalZBuffer, o = e.vertexNormalIndexBuffer ? e.vertexNormalIndexBuffer : e.indexBuffer, n = e.transformedFaceNormalZBuffer, h = this.colorBuffer, l = this.zBuffer, f = this.selectionBuffer, u = e.faceCount, d = (s.length, 
e.internalId), p = e.material ? e.material : this.defaultMaterial, m = p.getPalette(), c = 0 == p.transparency, g = ~~(255 * p.transparency), C = 255 - g, y = e.isDoubleSided || this.isCullingDisabled;
if (1 != p.transparency) {
(!a || a.length < e.vertexNormalBuffer.length / 3) && (e.transformedVertexNormalZBuffer = new Array(e.vertexNormalBuffer.length / 3), 
a = e.transformedVertexNormalZBuffer), (!n || n.length < u) && (e.transformedFaceNormalZBuffer = new Array(u), 
n = e.transformedFaceNormalZBuffer), JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.vertexNormalBuffer, a), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, n);
for (var S = new Array(3), x = new Array(3), D = new Array(3), v = new Array(3), w = 0, b = 0; w < u; ) {
var B = n[w++];
if (y && (B = B > 0 ? B : -B), B < 0) do {} while (-1 != i[b++]); else {
var J, M, k, F, I, V, A;
M = 3 * i[b], I = o[b], k = 3 * i[++b], V = o[b], b++;
do {
F = 3 * (J = i[b]), A = o[b], b++, S[0] = ~~(s[M] + .5), x[0] = ~~(s[M + 1] + .5), 
D[0] = s[M + 2], S[1] = ~~(s[k] + .5), x[1] = ~~(s[k + 1] + .5), D[1] = s[k + 2], 
S[2] = ~~(s[F] + .5), x[2] = ~~(s[F + 1] + .5), D[2] = s[F + 2], v[0] = a[I], v[1] = a[V], 
v[2] = a[A], y && (v[0] < 0 && (v[0] = -v[0]), v[1] < 0 && (v[1] = -v[1]), v[2] < 0 && (v[2] = -v[2]));
var N = x[0] < x[1] ? 0 : 1;
N = x[N] < x[2] ? N : 2;
var X = x[0] > x[1] ? 0 : 1, U = 3 - (X = x[X] > x[2] ? X : 2) - N;
if (N != X) {
var Y = S[X], L = D[X], T = 255 * v[X], R = x[X] - x[N];
R = 0 != R ? R : 1;
var P = (S[X] - S[N]) / R, Z = (D[X] - D[N]) / R, H = 255 * (v[X] - v[N]) / R, E = S[X], O = D[X], z = 255 * v[X], W = x[X] - x[U];
W = 0 != W ? W : 1;
var q = (S[X] - S[U]) / W, j = (D[X] - D[U]) / W, K = 255 * (v[X] - v[U]) / W, G = S[U], _ = D[U], Q = 255 * v[U], $ = x[U] - x[N];
$ = 0 != $ ? $ : 1;
for (var ee = (S[U] - S[N]) / $, te = (D[U] - D[N]) / $, re = 255 * (v[U] - v[N]) / $, ie = x[X] * t, se = x[X]; se > x[N]; se--) {
if (se >= 0 && se < r) {
var ae, oe, ne, he, le = ~~Y, fe = L, ue = T;
if (se > x[U] ? (ae = ~~E, oe = O, ne = z) : (ae = ~~G, oe = _, ne = Q), le > ae) he = le, 
le = ae, ae = he, he = fe, fe = oe, oe = he, he = ue, ue = ne, ne = he;
var de = le != ae ? (oe - fe) / (ae - le) : 1, pe = le != ae ? (ne - ue) / (ae - le) : 1;
le < 0 && (fe -= le * de, ue -= le * pe, le = 0), ae >= t && (ae = t - 1);
var me = ie + le;
if (c) for (var ce = le, ge = fe, Ce = ue; ce <= ae; ce++, ge += de, Ce += pe) ge > l[me] && (l[me] = ge, 
h[me] = 4278190080 | m[Ce > 0 ? ~~Ce : 0], f[me] = d), me++; else for (ce = le, 
ge = fe, Ce = ue; ce < ae; ce++, ge += de, Ce += pe) {
if (ge > l[me]) {
var ye = m[Ce > 0 ? ~~Ce : 0], Se = h[me], xe = (16711680 & Se) * g + (16711680 & ye) * C >> 8, De = (65280 & Se) * g + (65280 & ye) * C >> 8, ve = (255 & Se) * g + (255 & ye) * C >> 8, we = 4278190080 & Se | C << 24;
h[me] = we | 16711680 & xe | 65280 & De | 255 & ve, f[me] = d;
}
me++;
}
}
Y -= P, L -= Z, T -= H, se > x[U] ? (E -= q, O -= j, z -= K) : (G -= ee, _ -= te, 
Q -= re), ie -= t;
}
}
k = F, J, V = A;
} while (-1 != i[b]);
b++;
}
}
}
}, JSC3D.Viewer.prototype.renderSolidTexture = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedFaceNormalZBuffer, o = this.colorBuffer, n = this.zBuffer, h = this.selectionBuffer, l = e.faceCount, f = e.internalId, u = e.texture, d = !u.hasTransparency, p = e.texCoordBuffer, m = e.texCoordIndexBuffer ? e.texCoordIndexBuffer : e.indexBuffer, c = u.data, g = u.width, C = g - 1, y = u.hasMipmap() ? u.mipmaps : null, S = y ? u.mipentries : null, x = e.isDoubleSided || this.isCullingDisabled;
(!a || a.length < l) && (e.transformedFaceNormalZBuffer = new Array(l), a = e.transformedFaceNormalZBuffer), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, a);
for (var D = new Array(3), v = new Array(3), w = new Array(3), b = new Array(3), B = new Array(3), J = 0, M = 0; J < l; ) {
var k = a[J++];
if (x && (k = k > 0 ? k : -k), k < 0) do {} while (-1 != i[M++]); else {
var F, I, V, A, N, X;
if (F = 3 * i[M], A = 2 * m[M], I = 3 * i[++M], N = 2 * m[M], M++, y) {
V = 3 * i[M], X = 2 * m[M], g = u.width, D[0] = s[F], v[0] = s[F + 1], D[1] = s[I], 
v[1] = s[I + 1], D[2] = s[V], v[2] = s[V + 1], b[0] = p[A] * g, B[0] = p[A + 1] * g, 
b[1] = p[N] * g, B[1] = p[N + 1] * g, b[2] = p[X] * g, B[2] = p[X + 1] * g;
var U = (D[1] - D[0]) * (v[2] - v[0]) - (v[1] - v[0]) * (D[2] - D[0]);
U < 0 && (U = -U), U += 1;
var Y = (b[1] - b[0]) * (B[2] - B[0]) - (B[1] - B[0]) * (b[2] - b[0]);
Y < 0 && (Y = -Y);
var L = Y / U, T = 0;
if (L < S[1]) T = 0; else if (L >= S[S.length - 1]) T = S.length - 1, g = 1; else for (;L >= S[T + 1]; ) T++, 
g /= 2;
c = y[T], C = g - 1;
}
do {
V = 3 * i[M], X = 2 * m[M], M++, D[0] = ~~(s[F] + .5), v[0] = ~~(s[F + 1] + .5), 
w[0] = s[F + 2], D[1] = ~~(s[I] + .5), v[1] = ~~(s[I + 1] + .5), w[1] = s[I + 2], 
D[2] = ~~(s[V] + .5), v[2] = ~~(s[V + 1] + .5), w[2] = s[V + 2], b[0] = p[A] * g, 
B[0] = p[A + 1] * g, b[1] = p[N] * g, B[1] = p[N + 1] * g, b[2] = p[X] * g, B[2] = p[X + 1] * g;
var R = v[0] < v[1] ? 0 : 1;
R = v[R] < v[2] ? R : 2;
var P = v[0] > v[1] ? 0 : 1, Z = 3 - (P = v[P] > v[2] ? P : 2) - R;
if (R != P) {
var H = D[P], E = w[P], O = b[P], z = B[P], W = v[P] - v[R];
W = 0 != W ? W : 1;
var q = (D[P] - D[R]) / W, j = (w[P] - w[R]) / W, K = (b[P] - b[R]) / W, G = (B[P] - B[R]) / W, _ = D[P], Q = w[P], $ = b[P], ee = B[P], te = v[P] - v[Z];
te = 0 != te ? te : 1;
var re = (D[P] - D[Z]) / te, ie = (w[P] - w[Z]) / te, se = (b[P] - b[Z]) / te, ae = (B[P] - B[Z]) / te, oe = D[Z], ne = w[Z], he = b[Z], le = B[Z], fe = v[Z] - v[R];
fe = 0 != fe ? fe : 1;
for (var ue = (D[Z] - D[R]) / fe, de = (w[Z] - w[R]) / fe, pe = (b[Z] - b[R]) / fe, me = (B[Z] - B[R]) / fe, ce = v[P] * t, ge = v[P]; ge > v[R]; ge--) {
if (ge >= 0 && ge < r) {
var Ce, ye, Se, xe, De, ve = ~~H, we = E, be = O, Be = z;
if (ge > v[Z] ? (Ce = ~~_, ye = Q, Se = $, xe = ee) : (Ce = ~~oe, ye = ne, Se = he, 
xe = le), ve > Ce) De = ve, ve = Ce, Ce = De, De = we, we = ye, ye = De, De = be, 
be = Se, Se = De, De = Be, Be = xe, xe = De;
var Je = ve != Ce ? (ye - we) / (Ce - ve) : 1, Me = ve != Ce ? (Se - be) / (Ce - ve) : 1, ke = ve != Ce ? (xe - Be) / (Ce - ve) : 1;
ve < 0 && (we -= ve * Je, be -= ve * Me, Be -= ve * ke, ve = 0), Ce >= t && (Ce = t - 1);
var Fe = ce + ve;
if (d) for (var Ie = ve, Ve = we, Ae = be, Ne = Be; Ie <= Ce; Ie++, Ve += Je, Ae += Me, 
Ne += ke) Ve > n[Fe] && (n[Fe] = Ve, o[Fe] = c[(Ne & C) * g + (Ae & C)], h[Fe] = f), 
Fe++; else for (Ie = ve, Ve = we, Ae = be, Ne = Be; Ie < Ce; Ie++, Ve += Je, Ae += Me, 
Ne += ke) {
if (Ve > n[Fe]) {
var Xe = c[(Ne & C) * g + (Ae & C)], Ue = o[Fe], Ye = Xe >> 24 & 255, Le = 255 - Ye, Te = (16711680 & Ue) * Le + (16711680 & Xe) * Ye >> 8, Re = (65280 & Ue) * Le + (65280 & Xe) * Ye >> 8, Pe = (255 & Ue) * Le + (255 & Xe) * Ye >> 8, Ze = 4278190080 & Ue | Ye << 24;
o[Fe] = Ze | 16711680 & Te | 65280 & Re | 255 & Pe, h[Fe] = f;
}
Fe++;
}
}
H -= q, E -= j, O -= K, z -= G, ge > v[Z] ? (_ -= re, Q -= ie, $ -= se, ee -= ae) : (oe -= ue, 
ne -= de, he -= pe, le -= me), ce -= t;
}
}
I = V, N = X;
} while (-1 != i[M]);
M++;
}
}
}, JSC3D.Viewer.prototype.renderTextureFlat = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedFaceNormalZBuffer, o = this.colorBuffer, n = this.zBuffer, h = this.selectionBuffer, l = e.faceCount, f = e.internalId, u = e.material ? e.material : this.defaultMaterial, d = u.getPalette(), p = e.texture, m = 0 == u.transparency && !p.hasTransparency, c = ~~(255 * (1 - u.transparency)), g = e.texCoordBuffer, C = e.texCoordIndexBuffer ? e.texCoordIndexBuffer : e.indexBuffer, y = p.data, S = p.width, x = S - 1, D = p.hasMipmap() ? p.mipmaps : null, v = D ? p.mipentries : null, w = e.isDoubleSided || this.isCullingDisabled;
if (1 != u.transparency) {
(!a || a.length < l) && (e.transformedFaceNormalZBuffer = new Array(l), a = e.transformedFaceNormalZBuffer), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, a);
for (var b = new Array(3), B = new Array(3), J = new Array(3), M = new Array(3), k = new Array(3), F = 0, I = 0; F < l; ) {
var V = a[F++];
if (w && (V = V > 0 ? V : -V), V < 0) do {} while (-1 != i[I++]); else {
var A, N, X, U, Y, L, T = 4278190080 | d[~~(255 * V)];
if (A = 3 * i[I], U = 2 * C[I], N = 3 * i[++I], Y = 2 * C[I], I++, D) {
X = 3 * i[I], L = 2 * C[I], S = p.width, b[0] = s[A], B[0] = s[A + 1], b[1] = s[N], 
B[1] = s[N + 1], b[2] = s[X], B[2] = s[X + 1], M[0] = g[U] * S, k[0] = g[U + 1] * S, 
M[1] = g[Y] * S, k[1] = g[Y + 1] * S, M[2] = g[L] * S, k[2] = g[L + 1] * S;
var R = (b[1] - b[0]) * (B[2] - B[0]) - (B[1] - B[0]) * (b[2] - b[0]);
R < 0 && (R = -R), R += 1;
var P = (M[1] - M[0]) * (k[2] - k[0]) - (k[1] - k[0]) * (M[2] - M[0]);
P < 0 && (P = -P);
var Z = P / R, H = 0;
if (Z < v[1]) H = 0; else if (Z >= v[v.length - 1]) H = v.length - 1, S = 1; else for (;Z >= v[H + 1]; ) H++, 
S /= 2;
y = D[H], x = S - 1;
}
do {
X = 3 * i[I], L = 2 * C[I], I++, b[0] = ~~(s[A] + .5), B[0] = ~~(s[A + 1] + .5), 
J[0] = s[A + 2], b[1] = ~~(s[N] + .5), B[1] = ~~(s[N + 1] + .5), J[1] = s[N + 2], 
b[2] = ~~(s[X] + .5), B[2] = ~~(s[X + 1] + .5), J[2] = s[X + 2], M[0] = g[U] * S, 
k[0] = g[U + 1] * S, M[1] = g[Y] * S, k[1] = g[Y + 1] * S, M[2] = g[L] * S, k[2] = g[L + 1] * S;
var E = B[0] < B[1] ? 0 : 1;
E = B[E] < B[2] ? E : 2;
var O = B[0] > B[1] ? 0 : 1, z = 3 - (O = B[O] > B[2] ? O : 2) - E;
if (E != O) {
var W = b[O], q = J[O], j = M[O], K = k[O], G = B[O] - B[E];
G = 0 != G ? G : 1;
var _ = (b[O] - b[E]) / G, Q = (J[O] - J[E]) / G, $ = (M[O] - M[E]) / G, ee = (k[O] - k[E]) / G, te = b[O], re = J[O], ie = M[O], se = k[O], ae = B[O] - B[z];
ae = 0 != ae ? ae : 1;
var oe = (b[O] - b[z]) / ae, ne = (J[O] - J[z]) / ae, he = (M[O] - M[z]) / ae, le = (k[O] - k[z]) / ae, fe = b[z], ue = J[z], de = M[z], pe = k[z], me = B[z] - B[E];
me = 0 != me ? me : 1;
for (var ce = (b[z] - b[E]) / me, ge = (J[z] - J[E]) / me, Ce = (M[z] - M[E]) / me, ye = (k[z] - k[E]) / me, Se = B[O] * t, xe = B[O]; xe > B[E]; xe--) {
if (xe >= 0 && xe < r) {
var De, ve, we, be, Be, Je = ~~W, Me = q, ke = j, Fe = K;
if (xe > B[z] ? (De = ~~te, ve = re, we = ie, be = se) : (De = ~~fe, ve = ue, we = de, 
be = pe), Je > De) Be = Je, Je = De, De = Be, Be = Me, Me = ve, ve = Be, Be = ke, 
ke = we, we = Be, Be = Fe, Fe = be, be = Be;
var Ie = Je != De ? (ve - Me) / (De - Je) : 1, Ve = Je != De ? (we - ke) / (De - Je) : 1, Ae = Je != De ? (be - Fe) / (De - Je) : 1;
Je < 0 && (Me -= Je * Ie, ke -= Je * Ve, Fe -= Je * Ae, Je = 0), De >= t && (De = t - 1);
var Ne = Se + Je;
if (m) for (var Xe = Je, Ue = Me, Ye = ke, Le = Fe; Xe <= De; Xe++, Ue += Ie, Ye += Ve, 
Le += Ae) {
if (Ue > n[Ne]) {
n[Ne] = Ue;
var Te = y[(Le & x) * S + (Ye & x)], Re = ((16711680 & T) >> 16) * ((16711680 & Te) >> 8), Pe = ((65280 & T) >> 8) * ((65280 & Te) >> 8), Ze = (255 & T) * (255 & Te) >> 8;
o[Ne] = 4278190080 | 16711680 & Re | 65280 & Pe | 255 & Ze, h[Ne] = f;
}
Ne++;
} else for (Xe = Je, Ue = Me, Ye = ke, Le = Fe; Xe < De; Xe++, Ue += Ie, Ye += Ve, 
Le += Ae) {
if (Ue > n[Ne]) {
var He = y[(Le & x) * S + (Ye & x)], Ee = o[Ne], Oe = (He >> 24 & 255) * (255 & c) >> 8, ze = (Re = ((16711680 & T) >> 16) * ((16711680 & He) >> 8), 
Pe = ((65280 & T) >> 8) * ((65280 & He) >> 8), Ze = (255 & T) * (255 & He) >> 8, 
4278190080 & Ee | Oe << 24);
if (Oe > 250) n[Ne] = Ue; else {
var We = 255 - Oe;
Re = Re * Oe + (16711680 & Ee) * We >> 8, Pe = Pe * Oe + (65280 & Ee) * We >> 8, 
Ze = Ze * Oe + (255 & Ee) * We >> 8;
}
o[Ne] = ze | 16711680 & Re | 65280 & Pe | 255 & Ze, h[Ne] = f;
}
Ne++;
}
}
W -= _, q -= Q, j -= $, K -= ee, xe > B[z] ? (te -= oe, re -= ne, ie -= he, se -= le) : (fe -= ce, 
ue -= ge, de -= Ce, pe -= ye), Se -= t;
}
}
N = X, Y = L;
} while (-1 != i[I]);
I++;
}
}
}
}, JSC3D.Viewer.prototype.renderTextureSmooth = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedVertexNormalZBuffer, o = e.vertexNormalIndexBuffer ? e.vertexNormalIndexBuffer : e.indexBuffer, n = e.transformedFaceNormalZBuffer, h = this.colorBuffer, l = this.zBuffer, f = this.selectionBuffer, u = e.faceCount, d = e.internalId, p = (s.length, 
e.material ? e.material : this.defaultMaterial), m = p.getPalette(), c = e.texture, g = 0 == p.transparency && !c.hasTransparency, C = ~~(255 * (1 - p.transparency)), y = e.texCoordBuffer, S = e.texCoordIndexBuffer ? e.texCoordIndexBuffer : e.indexBuffer, x = c.data, D = c.width, v = D - 1, w = c.hasMipmap() ? c.mipmaps : null, b = w ? c.mipentries : null, B = e.isDoubleSided || this.isCullingDisabled;
if (1 != p.transparency) {
(!a || a.length < e.vertexNormalBuffer.length / 3) && (e.transformedVertexNormalZBuffer = new Array(e.vertexNormalBuffer.length / 3), 
a = e.transformedVertexNormalZBuffer), (!n || n.length < u) && (e.transformedFaceNormalZBuffer = new Array(u), 
n = e.transformedFaceNormalZBuffer), JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.vertexNormalBuffer, a), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, n);
for (var J = new Array(3), M = new Array(3), k = new Array(3), F = new Array(3), I = new Array(3), V = new Array(3), A = 0, N = 0; A < u; ) {
var X = n[A++];
if (B && (X = X > 0 ? X : -X), X < 0) do {} while (-1 != i[N++]); else {
var U, Y, L, T, R, P, Z, H, E, O;
if (Y = 3 * i[N], R = 2 * S[N], H = o[N], L = 3 * i[++N], P = 2 * S[N], E = o[N], 
N++, w) {
T = 3 * i[N], Z = 2 * S[N], D = c.width, J[0] = s[Y], M[0] = s[Y + 1], J[1] = s[L], 
M[1] = s[L + 1], J[2] = s[T], M[2] = s[T + 1], I[0] = y[R] * D, V[0] = y[R + 1] * D, 
I[1] = y[P] * D, V[1] = y[P + 1] * D, I[2] = y[Z] * D, V[2] = y[Z + 1] * D;
var z = (J[1] - J[0]) * (M[2] - M[0]) - (M[1] - M[0]) * (J[2] - J[0]);
z < 0 && (z = -z), z += 1;
var W = (I[1] - I[0]) * (V[2] - V[0]) - (V[1] - V[0]) * (I[2] - I[0]);
W < 0 && (W = -W);
var q = W / z, j = 0;
if (q < b[1]) j = 0; else if (q >= b[b.length - 1]) j = b.length - 1, D = 1; else for (;q >= b[j + 1]; ) j++, 
D /= 2;
x = w[j], v = D - 1;
}
do {
T = 3 * (U = i[N]), Z = 2 * S[N], O = o[N], N++, J[0] = ~~(s[Y] + .5), M[0] = ~~(s[Y + 1] + .5), 
k[0] = s[Y + 2], J[1] = ~~(s[L] + .5), M[1] = ~~(s[L + 1] + .5), k[1] = s[L + 2], 
J[2] = ~~(s[T] + .5), M[2] = ~~(s[T + 1] + .5), k[2] = s[T + 2], I[0] = y[R] * D, 
V[0] = y[R + 1] * D, I[1] = y[P] * D, V[1] = y[P + 1] * D, I[2] = y[Z] * D, V[2] = y[Z + 1] * D, 
F[0] = a[H], F[1] = a[E], F[2] = a[O], B && (F[0] < 0 && (F[0] = -F[0]), F[1] < 0 && (F[1] = -F[1]), 
F[2] < 0 && (F[2] = -F[2]));
var K = M[0] < M[1] ? 0 : 1;
K = M[K] < M[2] ? K : 2;
var G = M[0] > M[1] ? 0 : 1, _ = 3 - (G = M[G] > M[2] ? G : 2) - K;
if (K != G) {
var Q = J[G], $ = k[G], ee = I[G], te = V[G], re = 255 * F[G], ie = M[G] - M[K];
ie = 0 != ie ? ie : 1;
var se = (J[G] - J[K]) / ie, ae = (k[G] - k[K]) / ie, oe = (I[G] - I[K]) / ie, ne = (V[G] - V[K]) / ie, he = 255 * (F[G] - F[K]) / ie, le = J[G], fe = k[G], ue = I[G], de = V[G], pe = 255 * F[G], me = M[G] - M[_];
me = 0 != me ? me : 1;
var ce = (J[G] - J[_]) / me, ge = (k[G] - k[_]) / me, Ce = (I[G] - I[_]) / me, ye = (V[G] - V[_]) / me, Se = 255 * (F[G] - F[_]) / me, xe = J[_], De = k[_], ve = I[_], we = V[_], be = 255 * F[_], Be = M[_] - M[K];
Be = 0 != Be ? Be : 1;
for (var Je = (J[_] - J[K]) / Be, Me = (k[_] - k[K]) / Be, ke = (I[_] - I[K]) / Be, Fe = (V[_] - V[K]) / Be, Ie = 255 * (F[_] - F[K]) / Be, Ve = M[G] * t, Ae = M[G]; Ae > M[K]; Ae--) {
if (Ae >= 0 && Ae < r) {
var Ne, Xe, Ue, Ye, Le, Te, Re = ~~Q, Pe = $, Ze = ee, He = te, Ee = re;
if (Ae > M[_] ? (Ne = ~~le, Xe = fe, Ue = ue, Ye = de, Le = pe) : (Ne = ~~xe, Xe = De, 
Ue = ve, Ye = we, Le = be), Re > Ne) Te = Re, Re = Ne, Ne = Te, Te = Pe, Pe = Xe, 
Xe = Te, Te = Ze, Ze = Ue, Ue = Te, Te = He, He = Ye, Ye = Te, Te = Ee, Ee = Le, 
Le = Te;
var Oe = Re != Ne ? (Xe - Pe) / (Ne - Re) : 1, ze = Re != Ne ? (Ue - Ze) / (Ne - Re) : 1, We = Re != Ne ? (Ye - He) / (Ne - Re) : 1, qe = Re != Ne ? (Le - Ee) / (Ne - Re) : 0;
Re < 0 && (Pe -= Re * Oe, Ze -= Re * ze, He -= Re * We, Ee -= Re * qe, Re = 0), 
Ne >= t && (Ne = t - 1);
var je = Ve + Re;
if (g) for (var Ke = Re, Ge = Pe, _e = Ee, Qe = Ze, $e = He; Ke <= Ne; Ke++, Ge += Oe, 
_e += qe, Qe += ze, $e += We) {
if (Ge > l[je]) {
l[je] = Ge;
var et = m[_e > 0 ? ~~_e : 0], tt = x[($e & v) * D + (Qe & v)], rt = ((16711680 & et) >> 16) * ((16711680 & tt) >> 8), it = ((65280 & et) >> 8) * ((65280 & tt) >> 8), st = (255 & et) * (255 & tt) >> 8;
h[je] = 4278190080 | 16711680 & rt | 65280 & it | 255 & st, f[je] = d;
}
je++;
} else for (Ke = Re, Ge = Pe, _e = Ee, Qe = Ze, $e = He; Ke < Ne; Ke++, Ge += Oe, 
_e += qe, Qe += ze, $e += We) {
if (Ge > l[je]) {
et = m[_e > 0 ? ~~_e : 0];
var at = x[($e & v) * D + (Qe & v)], ot = h[je], nt = (at >> 24 & 255) * (255 & C) >> 8, ht = (rt = ((16711680 & et) >> 16) * ((16711680 & at) >> 8), 
it = ((65280 & et) >> 8) * ((65280 & at) >> 8), st = (255 & et) * (255 & at) >> 8, 
4278190080 & ot | nt << 24);
if (nt > 250) l[je] = Ge; else {
var lt = 255 - nt;
rt = rt * nt + (16711680 & ot) * lt >> 8, it = it * nt + (65280 & ot) * lt >> 8, 
st = st * nt + (255 & ot) * lt >> 8;
}
h[je] = ht | 16711680 & rt | 65280 & it | 255 & st, f[je] = d;
}
je++;
}
}
Q -= se, $ -= ae, ee -= oe, te -= ne, re -= he, Ae > M[_] ? (le -= ce, fe -= ge, 
ue -= Ce, de -= ye, pe -= Se) : (xe -= Je, De -= Me, ve -= ke, we -= Fe, be -= Ie), 
Ve -= t;
}
}
U, L = T, P = Z, E = O;
} while (-1 != i[N]);
N++;
}
}
}
}, JSC3D.Viewer.prototype.renderSolidSphereMapped = function(e) {
var t = this.frameWidth, r = this.frameHeight, i = e.indexBuffer, s = e.transformedVertexBuffer, a = e.transformedVertexNormalBuffer, o = e.vertexNormalIndexBuffer ? e.vertexNormalIndexBuffer : e.indexBuffer, n = e.transformedFaceNormalZBuffer, h = this.colorBuffer, l = this.zBuffer, f = this.selectionBuffer, u = e.faceCount, d = (s.length, 
e.internalId), p = e.material ? e.material : this.defaultMaterial, m = p.getPalette(), c = this.sphereMap, g = c.data, C = c.width, y = C - 1, S = 0 == p.transparency, x = ~~(255 * p.transparency), D = 255 - x, v = e.isDoubleSided || this.isCullingDisabled;
if (1 != p.transparency) {
(!a || a.length < e.vertexNormalBuffer.length) && (e.transformedVertexNormalBuffer = new Array(e.vertexNormalBuffer.length), 
a = e.transformedVertexNormalBuffer), (!n || n.length < u) && (e.transformedFaceNormalZBuffer = new Array(u), 
n = e.transformedFaceNormalZBuffer), JSC3D.Math3D.transformVectors(this.rotMatrix, e.vertexNormalBuffer, a), 
JSC3D.Math3D.transformVectorZs(this.rotMatrix, e.faceNormalBuffer, n);
for (var w = new Array(3), b = new Array(3), B = new Array(3), J = new Array(3), M = new Array(3), k = new Array(3), F = 0, I = 0; F < u; ) {
var V = n[F++];
if (v && (V = V > 0 ? V : -V), V < 0) do {} while (-1 != i[I++]); else {
var A, N, X, U, Y, L;
A = 3 * i[I], U = 3 * o[I], N = 3 * i[++I], Y = 3 * o[I], I++;
do {
X = 3 * i[I], L = 3 * o[I], I++, w[0] = ~~(s[A] + .5), b[0] = ~~(s[A + 1] + .5), 
B[0] = s[A + 2], w[1] = ~~(s[N] + .5), b[1] = ~~(s[N + 1] + .5), B[1] = s[N + 2], 
w[2] = ~~(s[X] + .5), b[2] = ~~(s[X + 1] + .5), B[2] = s[X + 2], J[0] = a[U], M[0] = a[U + 1], 
k[0] = a[U + 2], J[1] = a[Y], M[1] = a[Y + 1], k[1] = a[Y + 2], J[2] = a[L], M[2] = a[L + 1], 
k[2] = a[L + 2], v && (k[0] < 0 && (k[0] = -k[0]), k[1] < 0 && (k[1] = -k[1]), k[2] < 0 && (k[2] = -k[2]));
var T = b[0] < b[1] ? 0 : 1;
T = b[T] < b[2] ? T : 2;
var R = b[0] > b[1] ? 0 : 1, P = 3 - (R = b[R] > b[2] ? R : 2) - T;
if (T != R) {
var Z = w[R], H = B[R], E = 255 * k[R], O = (J[R] / 2 + .5) * C & y, z = (.5 - M[R] / 2) * C & y, W = b[R] - b[T];
W = 0 != W ? W : 1;
var q = (w[R] - w[T]) / W, j = (B[R] - B[T]) / W, K = 255 * (k[R] - k[T]) / W, G = (J[R] - J[T]) / 2 * C / W, _ = (M[T] - M[R]) / 2 * C / W, Q = w[R], $ = B[R], ee = 255 * k[R], te = (J[R] / 2 + .5) * C & y, re = (.5 - M[R] / 2) * C & y, ie = b[R] - b[P];
ie = 0 != ie ? ie : 1;
var se = (w[R] - w[P]) / ie, ae = (B[R] - B[P]) / ie, oe = 255 * (k[R] - k[P]) / ie, ne = (J[R] - J[P]) / 2 * C / ie, he = (M[P] - M[R]) / 2 * C / ie, le = w[P], fe = B[P], ue = 255 * k[P], de = (J[P] / 2 + .5) * C & y, pe = (.5 - M[P] / 2) * C & y, me = b[P] - b[T];
me = 0 != me ? me : 1;
for (var ce = (w[P] - w[T]) / me, ge = (B[P] - B[T]) / me, Ce = 255 * (k[P] - k[T]) / me, ye = (J[P] - J[T]) / 2 * C / me, Se = (M[T] - M[P]) / 2 * C / me, xe = b[R] * t, De = b[R]; De > b[T]; De--) {
if (De >= 0 && De < r) {
var ve, we, be, Be, Je, Me, ke = ~~Z, Fe = H, Ie = E, Ve = O, Ae = z;
if (De > b[P] ? (ve = ~~Q, we = $, be = ee, Be = te, Je = re) : (ve = ~~le, we = fe, 
be = ue, Be = de, Je = pe), ke > ve) Me = ke, ke = ve, ve = Me, Me = Fe, Fe = we, 
we = Me, Me = Ie, Ie = be, be = Me, Me = Ve, Ve = Be, Be = Me, Me = Ae, Ae = Je, 
Je = Me;
var Ne = ke != ve ? (we - Fe) / (ve - ke) : 1, Xe = ke != ve ? (be - Ie) / (ve - ke) : 1, Ue = ke != ve ? (Be - Ve) / (ve - ke) : 1, Ye = ke != ve ? (Je - Ae) / (ve - ke) : 1;
ke < 0 && (Fe -= ke * Ne, Ie -= ke * Xe, Ve -= Ve * Ue, Ae -= Ae * Ye, ke = 0), 
ve >= t && (ve = t - 1);
var Le = xe + ke;
if (S) for (var Te = ke, Re = Fe, Pe = Ie, Ze = Ve, He = Ae; Te <= ve; Te++, Re += Ne, 
Pe += Xe, Ze += Ue, He += Ye) {
if (Re > l[Le]) {
l[Le] = Re;
var Ee = m[Pe > 0 ? ~~Pe : 0], Oe = g[(He & y) * C + (Ze & y)], ze = ((16711680 & Ee) >> 16) * ((16711680 & Oe) >> 8), We = ((65280 & Ee) >> 8) * ((65280 & Oe) >> 8), qe = (255 & Ee) * (255 & Oe) >> 8;
h[Le] = 4278190080 | 16711680 & ze | 65280 & We | 255 & qe, f[Le] = d;
}
Le++;
} else for (Te = ke, Re = Fe, Pe = Ie, Ze = Ve, He = Ae; Te < ve; Te++, Re += Ne, 
Pe += Xe, Ze += Ue, He += Ye) {
if (Re > l[Le]) {
Ee = m[Pe > 0 ? ~~Pe : 0];
var je = g[(He & y) * C + (Ze & y)], Ke = h[Le], Ge = 4278190080 & (Ke | Ee);
ze = (ze = ((16711680 & Ee) >> 16) * ((16711680 & je) >> 8)) * D + (16711680 & Ke) * x >> 8, 
We = (We = ((65280 & Ee) >> 8) * ((65280 & je) >> 8)) * D + (65280 & Ke) * x >> 8, 
qe = (qe = (255 & Ee) * (255 & je) >> 8) * D + (255 & Ke) * x >> 8, h[Le] = Ge | 16711680 & ze | 65280 & We | 255 & qe, 
f[Le] = d;
}
Le++;
}
}
Z -= q, H -= j, E -= K, O -= G, z -= _, De > b[P] ? (Q -= se, $ -= ae, ee -= oe, 
te -= ne, re -= he) : (le -= ce, fe -= ge, ue -= Ce, de -= ye, pe -= Se), xe -= t;
}
}
N = X, Y = L;
} while (-1 != i[I]);
I++;
}
}
}
}, JSC3D.Viewer.prototype.params = null, JSC3D.Viewer.prototype.widget = null, JSC3D.Viewer.prototype.ctx2d = null, 
JSC3D.Viewer.prototype.canvasData = null, JSC3D.Viewer.prototype.bkgColorBuffer = null, 
JSC3D.Viewer.prototype.colorBuffer = null, JSC3D.Viewer.prototype.zBuffer = null, 
JSC3D.Viewer.prototype.selectionBuffer = null, JSC3D.Viewer.prototype.frameWidth = 0, 
JSC3D.Viewer.prototype.frameHeight = 0, JSC3D.Viewer.prototype.scene = null, JSC3D.Viewer.prototype.defaultMaterial = null, 
JSC3D.Viewer.prototype.sphereMap = null, JSC3D.Viewer.prototype.isLoaded = !1, JSC3D.Viewer.prototype.isFailed = !1, 
JSC3D.Viewer.prototype.needUpdate = !1, JSC3D.Viewer.prototype.needRepaint = !1, 
JSC3D.Viewer.prototype.initRotX = 0, JSC3D.Viewer.prototype.initRotY = 0, JSC3D.Viewer.prototype.initRotZ = 0, 
JSC3D.Viewer.prototype.zoomFactor = 1, JSC3D.Viewer.prototype.panning = [ 0, 0 ], 
JSC3D.Viewer.prototype.rotMatrix = null, JSC3D.Viewer.prototype.transformMatrix = null, 
JSC3D.Viewer.prototype.sceneUrl = "", JSC3D.Viewer.prototype.modelColor = 13280792, 
JSC3D.Viewer.prototype.bkgColor1 = 16777215, JSC3D.Viewer.prototype.bkgColor2 = 16777088, 
JSC3D.Viewer.prototype.renderMode = "flat", JSC3D.Viewer.prototype.definition = "standard", 
JSC3D.Viewer.prototype.isCullingDisabled = !1, JSC3D.Viewer.prototype.isMipMappingOn = !1, 
JSC3D.Viewer.prototype.creaseAngle = -180, JSC3D.Viewer.prototype.sphereMapUrl = "", 
JSC3D.Viewer.prototype.showProgressBar = !0, JSC3D.Viewer.prototype.buttonStates = null, 
JSC3D.Viewer.prototype.keyStates = null, JSC3D.Viewer.prototype.mouseX = 0, JSC3D.Viewer.prototype.mouseY = 0, 
JSC3D.Viewer.prototype.onloadingstarted = null, JSC3D.Viewer.prototype.onloadingcomplete = null, 
JSC3D.Viewer.prototype.onloadingprogress = null, JSC3D.Viewer.prototype.onloadingaborted = null, 
JSC3D.Viewer.prototype.onloadingerror = null, JSC3D.Viewer.prototype.onmousedown = null, 
JSC3D.Viewer.prototype.onmouseup = null, JSC3D.Viewer.prototype.onmousemove = null, 
JSC3D.Viewer.prototype.onmousewheel = null, JSC3D.Viewer.prototype.onmouseclick = null, 
JSC3D.Viewer.prototype.beforeupdate = null, JSC3D.Viewer.prototype.afterupdate = null, 
JSC3D.Viewer.prototype.mouseUsage = "default", JSC3D.Viewer.prototype.isDefaultInputHandlerEnabled = !1, 
JSC3D.PickInfo = function() {
this.canvasX = 0, this.canvasY = 0, this.depth = -1 / 0, this.mesh = null;
}, JSC3D.Scene = function(e) {
this.name = e || "", this.srcUrl = "", this.aabb = null, this.children = [], this.maxChildId = 1;
}, JSC3D.Scene.prototype.init = function() {
if (!this.isEmpty()) {
for (var e = 0; e < this.children.length; e++) this.children[e].init();
this.aabb || (this.aabb = new JSC3D.AABB(), this.calcAABB());
}
}, JSC3D.Scene.prototype.isEmpty = function() {
return 0 == this.children.length;
}, JSC3D.Scene.prototype.addChild = function(e) {
e.internalId = this.maxChildId++, this.children.push(e);
}, JSC3D.Scene.prototype.removeChild = function(e) {
var t = this.children.indexOf(e);
t >= 0 && this.children.splice(t, 1);
}, JSC3D.Scene.prototype.getChildren = function() {
return this.children.slice(0);
}, JSC3D.Scene.prototype.forEachChild = function(e) {
if ("function" == typeof e) for (var t = 0; t < this.children.length && !e.call(null, this.children[t]); t++) ;
}, JSC3D.Scene.prototype.calcAABB = function() {
this.aabb.minX = this.aabb.minY = this.aabb.minZ = 1 / 0, this.aabb.maxX = this.aabb.maxY = this.aabb.maxZ = -1 / 0;
for (var e = 0; e < this.children.length; e++) {
var t = this.children[e];
if (!t.isTrivial()) {
var r = t.aabb.minX, i = t.aabb.minY, s = t.aabb.minZ, a = t.aabb.maxX, o = t.aabb.maxY, n = t.aabb.maxZ;
this.aabb.minX > r && (this.aabb.minX = r), this.aabb.minY > i && (this.aabb.minY = i), 
this.aabb.minZ > s && (this.aabb.minZ = s), this.aabb.maxX < a && (this.aabb.maxX = a), 
this.aabb.maxY < o && (this.aabb.maxY = o), this.aabb.maxZ < n && (this.aabb.maxZ = n);
}
}
}, JSC3D.Scene.prototype.name = "", JSC3D.Scene.prototype.srcUrl = "", JSC3D.Scene.prototype.aabb = null, 
JSC3D.Scene.prototype.children = null, JSC3D.Scene.prototype.maxChildId = 1, JSC3D.Mesh = function(e, t, r, i, s, a, o, n, h, l, f) {
this.name = e || "", this.metadata = "", this.visible = null == t || t, this.renderMode = null, 
this.aabb = null, this.vertexBuffer = n || null, this.indexBuffer = h || null, this.vertexNormalBuffer = null, 
this.vertexNormalIndexBuffer = null, this.faceNormalBuffer = null, this.material = r || null, 
this.texture = i || null, this.faceCount = 0, this.creaseAngle = s >= 0 ? s : -180, 
this.isDoubleSided = a || !1, this.isEnvironmentCast = o || !1, this.internalId = 0, 
this.texCoordBuffer = l || null, this.texCoordIndexBuffer = f || null, this.transformedVertexBuffer = null, 
this.transformedVertexNormalZBuffer = null, this.transformedFaceNormalZBuffer = null, 
this.transformedVertexNormalBuffer = null;
}, JSC3D.Mesh.prototype.init = function() {
this.isTrivial() || 0 == this.faceCount && (this.calcFaceCount(), 0 == this.faceCount) || (this.aabb || (this.aabb = new JSC3D.AABB(), 
this.calcAABB()), this.faceNormalBuffer || (this.faceNormalBuffer = new Array(3 * this.faceCount), 
this.calcFaceNormals()), this.vertexNormalBuffer || (this.creaseAngle >= 0 ? this.calcCreasedVertexNormals() : (this.vertexNormalBuffer = new Array(this.vertexBuffer.length), 
this.calcVertexNormals())), this.normalizeFaceNormals(), this.transformedVertexBuffer = new Array(this.vertexBuffer.length));
}, JSC3D.Mesh.prototype.isTrivial = function() {
return !this.vertexBuffer || this.vertexBuffer.length < 3 || !this.indexBuffer || this.indexBuffer.length < 3;
}, JSC3D.Mesh.prototype.setMaterial = function(e) {
this.material = e;
}, JSC3D.Mesh.prototype.setTexture = function(e) {
this.texture = e;
}, JSC3D.Mesh.prototype.hasTexture = function() {
return null != this.texture && this.texture.hasData() && null != this.texCoordBuffer && this.texCoordBuffer.length >= 2 && (null == this.texCoordIndexBuffer || this.texCoordIndexBuffer.length >= 3 && this.texCoordIndexBuffer.length >= this.indexBuffer.length);
}, JSC3D.Mesh.prototype.setRenderMode = function(e) {
this.renderMode = e;
}, JSC3D.Mesh.prototype.calcFaceCount = function() {
this.faceCount = 0;
var e = this.indexBuffer;
-1 != e[e.length - 1] && e.push(-1);
for (var t = 0; t < e.length; t++) -1 == e[t] && this.faceCount++;
}, JSC3D.Mesh.prototype.calcAABB = function() {
for (var e, t, r, i, s = e = t = 1 / 0, a = r = i = -1 / 0, o = this.vertexBuffer, n = 0; n < o.length; n += 3) {
var h = o[n], l = o[n + 1], f = o[n + 2];
h < s && (s = h), h > a && (a = h), l < e && (e = l), l > r && (r = l), f < t && (t = f), 
f > i && (i = f);
}
this.aabb.minX = s, this.aabb.minY = e, this.aabb.minZ = t, this.aabb.maxX = a, 
this.aabb.maxY = r, this.aabb.maxZ = i;
}, JSC3D.Mesh.prototype.calcFaceNormals = function() {
for (var e = this.vertexBuffer, t = this.indexBuffer, r = this.faceNormalBuffer, i = 0, s = 0; i < t.length; ) {
var a = 3 * t[i++], o = e[a], n = e[a + 1], h = e[a + 2], l = e[a = 3 * t[i++]] - o, f = e[a + 1] - n, u = e[a + 2] - h, d = e[a = 3 * t[i++]] - o, p = e[a + 1] - n, m = e[a + 2] - h, c = f * m - u * p, g = u * d - l * m, C = l * p - f * d;
r[s++] = c, r[s++] = g, r[s++] = C;
do {} while (-1 != t[i++]);
}
}, JSC3D.Mesh.prototype.normalizeFaceNormals = function() {
JSC3D.Math3D.normalizeVectors(this.faceNormalBuffer, this.faceNormalBuffer);
}, JSC3D.Mesh.prototype.calcVertexNormals = function() {
this.faceNormalBuffer || (this.faceNormalBuffer = new Array(3 * this.faceCount), 
this.calcFaceNormals());
for (var e = this.vertexBuffer, t = this.indexBuffer, r = this.faceNormalBuffer, i = this.vertexNormalBuffer, s = 0; s < i.length; s++) i[s] = 0;
this.vertexNormalIndexBuffer = null;
e.length, s = 0;
for (var a = 0, o = 0; s < t.length; ) if (-1 == (o = t[s++])) a += 3; else {
var n = 3 * o;
i[n] += r[a], i[n + 1] += r[a + 1], i[n + 2] += r[a + 2];
}
JSC3D.Math3D.normalizeVectors(i, i);
}, JSC3D.Mesh.prototype.calcCreasedVertexNormals = function() {
this.faceNormalBuffer || (this.faceNormalBuffer = new Array(3 * this.faceCount), 
this.calcFaceNormals());
for (var e = this.indexBuffer, t = this.vertexBuffer.length / 3, r = new Array(t), i = 0, s = 0, a = 0, o = 0; s < e.length; s++) {
if ((o = e[s]) >= 0) i += 3, (S = r[o]) ? S.push(a) : r[o] = [ a ]; else a++;
}
var n = this.faceNormalBuffer, h = new Array(n.length);
JSC3D.Math3D.normalizeVectors(n, h), (!this.vertexNormalBuffer || this.vertexNormalBuffer.length < i) && (this.vertexNormalBuffer = new Array(i));
var l = this.vertexNormalBuffer;
for (s = 0; s < l.length; s++) l[s] = 0;
this.vertexNormalIndexBuffer = [];
for (var f = this.vertexNormalIndexBuffer, u = Math.cos(this.creaseAngle * Math.PI / 180), d = (s = 0, 
o = 0, 0), p = 0; s < e.length; s++) if ((o = e[s]) >= 0) {
var m = 3 * d, c = 3 * p;
l[m] += n[c], l[m + 1] += n[c + 1], l[m + 2] += n[c + 2];
for (var g = h[c], C = h[c + 1], y = h[c + 2], S = r[o], x = 0; x < S.length; x++) {
var D = S[x];
if (p != D) {
var v = 3 * D;
g * h[v] + C * h[v + 1] + y * h[v + 2] > u && (l[m] += n[v], l[m + 1] += n[v + 1], 
l[m + 2] += n[v + 2]);
}
}
f.push(d++);
} else p++, f.push(-1);
JSC3D.Math3D.normalizeVectors(l, l);
}, JSC3D.Mesh.prototype.checkValid = function() {}, JSC3D.Mesh.prototype.name = "", 
JSC3D.Mesh.prototype.metadata = "", JSC3D.Mesh.prototype.visible = !1, JSC3D.Mesh.prototype.renderMode = "flat", 
JSC3D.Mesh.prototype.aabb = null, JSC3D.Mesh.prototype.vertexBuffer = null, JSC3D.Mesh.prototype.indexBuffer = null, 
JSC3D.Mesh.prototype.vertexNormalBuffer = null, JSC3D.Mesh.prototype.vertexNormalIndexBuffer = null, 
JSC3D.Mesh.prototype.faceNormalBuffer = null, JSC3D.Mesh.prototype.texCoordBuffer = null, 
JSC3D.Mesh.prototype.texCoordIndexBuffer = null, JSC3D.Mesh.prototype.material = null, 
JSC3D.Mesh.prototype.texture = null, JSC3D.Mesh.prototype.faceCount = 0, JSC3D.Mesh.prototype.creaseAngle = -180, 
JSC3D.Mesh.prototype.isDoubleSided = !1, JSC3D.Mesh.prototype.isEnvironmentCast = !1, 
JSC3D.Mesh.prototype.internalId = 0, JSC3D.Mesh.prototype.transformedVertexBuffer = null, 
JSC3D.Mesh.prototype.transformedVertexNormalZBuffer = null, JSC3D.Mesh.prototype.transformedFaceNormalZBuffer = null, 
JSC3D.Mesh.prototype.transformedVertexNormalBuffer = null, JSC3D.Material = function(e, t, r, i, s) {
this.name = e || "", this.diffuseColor = r || 8355711, this.ambientColor = "number" == typeof t ? t : (16711680 & this.diffuseColor) >> 3 & 16711680 | (65280 & this.diffuseColor) >> 3 & 65280 | (255 & this.diffuseColor) >> 3, 
this.transparency = i || 0, this.simulateSpecular = s || !1, this.palette = null;
}, JSC3D.Material.prototype.getPalette = function() {
return this.palette || (this.palette = new Array(256), this.generatePalette()), 
this.palette;
}, JSC3D.Material.prototype.generatePalette = function() {
var e = (16711680 & this.ambientColor) >> 16, t = (65280 & this.ambientColor) >> 8, r = 255 & this.ambientColor, i = (16711680 & this.diffuseColor) >> 16, s = (65280 & this.diffuseColor) >> 8, a = 255 & this.diffuseColor;
if (this.simulateSpecular) {
for (var o = 0; o < 204; ) {
(n = Math.max(e, o * i / 204)) > 255 && (n = 255), (h = Math.max(t, o * s / 204)) > 255 && (h = 255), 
(l = Math.max(r, o * a / 204)) > 255 && (l = 255), this.palette[o++] = n << 16 | h << 8 | l;
}
for (;o < 256; ) {
(n = Math.max(e, i + (o - 204) * (255 - i) / 82)) > 255 && (n = 255), (h = Math.max(t, s + (o - 204) * (255 - s) / 82)) > 255 && (h = 255), 
(l = Math.max(r, a + (o - 204) * (255 - a) / 82)) > 255 && (l = 255), this.palette[o++] = n << 16 | h << 8 | l;
}
} else for (o = 0; o < 256; ) {
var n, h, l;
(n = Math.max(e, o * i / 256)) > 255 && (n = 255), (h = Math.max(t, o * s / 256)) > 255 && (h = 255), 
(l = Math.max(r, o * a / 256)) > 255 && (l = 255), this.palette[o++] = n << 16 | h << 8 | l;
}
}, JSC3D.Material.prototype.name = "", JSC3D.Material.prototype.ambientColor = 0, 
JSC3D.Material.prototype.diffuseColor = 8355711, JSC3D.Material.prototype.transparency = 0, 
JSC3D.Material.prototype.simulateSpecular = !1, JSC3D.Material.prototype.palette = null, 
JSC3D.Texture = function(e, t) {
this.name = e || "", this.width = 0, this.height = 0, this.data = null, this.mipmaps = null, 
this.mipentries = null, this.hasTransparency = !1, this.srcUrl = "", this.onready = t && "function" == typeof t ? t : null;
}, JSC3D.Texture.prototype.createFromUrl = function(e, t) {
var r = this, i = new Image();
i.onload = function() {
r.data = null, r.mipmaps = null, r.mipentries = null, r.width = 0, r.height = 0, 
r.hasTransparency = !1, r.srcUrl = "", r.createFromImage(this, t), JSC3D.console && JSC3D.console.logInfo('Finished loading texture image file "' + this.src + '".');
}, i.onerror = function() {
r.data = null, r.mipmaps = null, r.mipentries = null, r.width = 0, r.height = 0, 
r.hasTransparency = !1, r.srcUrl = "", JSC3D.console && JSC3D.console.logWarning('Failed to load texture image file "' + this.src + '". This texture will be discarded.');
}, i.crossOrigin = "anonymous", i.src = encodeURI(e);
}, JSC3D.Texture.prototype.createFromImage = function(e, t) {
if (!(e.width <= 0 || e.height <= 0)) {
var r = !1, i = JSC3D.Texture.cv;
if (!i) try {
i = document.createElement("canvas"), JSC3D.Texture.cv = i, r = !0;
} catch (e) {
return;
}
var s, a = e.width > e.height ? e.width : e.height;
a = a <= 16 ? 16 : a <= 32 ? 32 : a <= 64 ? 64 : a <= 128 ? 128 : a <= 256 ? 256 : a <= 512 ? 512 : 1024, 
i.width == a && i.height == a || (i.width = i.height = a, r = !0);
try {
var o = new Canvas();
this.widget.add(o), r || o.clearRect(0, 0, a, a), o.drawImage(e, 0, 0, a, a), s = o.getImageData(0, 0, a, a).data;
} catch (e) {
return;
}
var n, h = s.length / 4;
this.data = new Array(h);
for (var l = 0, f = 0; l < h; l++, f += 4) n = s[f + 3], this.data[l] = n << 24 | s[f] << 16 | s[f + 1] << 8 | s[f + 2], 
n < 255 && (this.hasTransparency = !0);
this.width = a, this.height = a, this.mipmaps = null, t && this.generateMipmaps(), 
this.srcUrl = e.src, null != this.onready && "function" == typeof this.onready && this.onready();
}
}, JSC3D.Texture.prototype.hasData = function() {
return null != this.data;
}, JSC3D.Texture.prototype.generateMipmaps = function() {
if (!(this.width <= 1 || null == this.data || null != this.mipmaps)) {
this.mipmaps = [ this.data ], this.mipentries = [ 1 ];
for (var e = 1 + ~~(.1 + Math.log(this.width) * Math.LOG2E), t = this.width >> 1, r = 1; r < e; r++) {
for (var i = new Array(t * t), s = this.mipmaps[r - 1], a = t << 1, o = 0, n = 0, h = 0; h < t; h++) {
for (var l = 0; l < t; l++) {
var f = s[o], u = s[o + 1], d = s[o + a], p = s[o + a + 1], m = ((4278190080 & f) >>> 2) + ((4278190080 & u) >>> 2) + ((4278190080 & d) >>> 2) + ((4278190080 & p) >>> 2) & 4278190080, c = (16711680 & f) + (16711680 & u) + (16711680 & d) + (16711680 & p) >> 2 & 16711680, g = (65280 & f) + (65280 & u) + (65280 & d) + (65280 & p) >> 2 & 65280, C = (255 & f) + (255 & u) + (255 & d) + (255 & p) >> 2 & 255;
i[n] = m + c + g + C, o += 2, n++;
}
o += a;
}
this.mipmaps.push(i), this.mipentries.push(Math.pow(4, r)), t >>= 1;
}
}
}, JSC3D.Texture.prototype.hasMipmap = function() {
return null != this.mipmaps;
}, JSC3D.Texture.prototype.name = "", JSC3D.Texture.prototype.data = null, JSC3D.Texture.prototype.mipmaps = null, 
JSC3D.Texture.prototype.mipentries = null, JSC3D.Texture.prototype.width = 0, JSC3D.Texture.prototype.height = 0, 
JSC3D.Texture.prototype.hasTransparency = !1, JSC3D.Texture.prototype.srcUrl = "", 
JSC3D.Texture.prototype.onready = null, JSC3D.Texture.cv = null, JSC3D.AABB = function() {
this.minX = 0, this.minY = 0, this.minZ = 0, this.maxX = 0, this.maxY = 0, this.maxZ = 0;
}, JSC3D.AABB.prototype.center = function(e) {
return e ? (e[0] = .5 * (this.minX + this.maxX), e[1] = .5 * (this.minY + this.maxY), 
e[2] = .5 * (this.minZ + this.maxZ)) : e = [ .5 * (this.minX + this.maxX), .5 * (this.minY + this.maxY), .5 * (this.minZ + this.maxZ) ], 
e;
}, JSC3D.AABB.prototype.lengthOfDiagonal = function() {
var e = this.maxX - this.minX, t = this.maxY - this.minY, r = this.maxZ - this.minZ;
return Math.sqrt(e * e + t * t + r * r);
}, JSC3D.Matrix3x4 = function() {
this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m10 = 0, this.m11 = 1, 
this.m12 = 0, this.m13 = 0, this.m20 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0;
}, JSC3D.Matrix3x4.prototype.identity = function() {
this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m10 = 0, this.m11 = 1, 
this.m12 = 0, this.m13 = 0, this.m20 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0;
}, JSC3D.Matrix3x4.prototype.scale = function(e, t, r) {
this.m00 *= e, this.m01 *= e, this.m02 *= e, this.m03 *= e, this.m10 *= t, this.m11 *= t, 
this.m12 *= t, this.m13 *= t, this.m20 *= r, this.m21 *= r, this.m22 *= r, this.m23 *= r;
}, JSC3D.Matrix3x4.prototype.translate = function(e, t, r) {
this.m03 += e, this.m13 += t, this.m23 += r;
}, JSC3D.Matrix3x4.prototype.rotateAboutXAxis = function(e) {
if (0 != e) {
e *= Math.PI / 180;
var t = Math.cos(e), r = Math.sin(e), i = t * this.m10 - r * this.m20, s = t * this.m11 - r * this.m21, a = t * this.m12 - r * this.m22, o = t * this.m13 - r * this.m23, n = t * this.m20 + r * this.m10, h = t * this.m21 + r * this.m11, l = t * this.m22 + r * this.m12, f = t * this.m23 + r * this.m13;
this.m10 = i, this.m11 = s, this.m12 = a, this.m13 = o, this.m20 = n, this.m21 = h, 
this.m22 = l, this.m23 = f;
}
}, JSC3D.Matrix3x4.prototype.rotateAboutYAxis = function(e) {
if (0 != e) {
e *= Math.PI / 180;
var t = Math.cos(e), r = Math.sin(e), i = t * this.m00 + r * this.m20, s = t * this.m01 + r * this.m21, a = t * this.m02 + r * this.m22, o = t * this.m03 + r * this.m23, n = t * this.m20 - r * this.m00, h = t * this.m21 - r * this.m01, l = t * this.m22 - r * this.m02, f = t * this.m23 - r * this.m03;
this.m00 = i, this.m01 = s, this.m02 = a, this.m03 = o, this.m20 = n, this.m21 = h, 
this.m22 = l, this.m23 = f;
}
}, JSC3D.Matrix3x4.prototype.rotateAboutZAxis = function(e) {
if (0 != e) {
e *= Math.PI / 180;
var t = Math.cos(e), r = Math.sin(e), i = t * this.m10 + r * this.m00, s = t * this.m11 + r * this.m01, a = t * this.m12 + r * this.m02, o = t * this.m13 + r * this.m03, n = t * this.m00 - r * this.m10, h = t * this.m01 - r * this.m11, l = t * this.m02 - r * this.m12, f = t * this.m03 - r * this.m13;
this.m00 = n, this.m01 = h, this.m02 = l, this.m03 = f, this.m10 = i, this.m11 = s, 
this.m12 = a, this.m13 = o;
}
}, JSC3D.Matrix3x4.prototype.multiply = function(e) {
var t = e.m00 * this.m00 + e.m01 * this.m10 + e.m02 * this.m20, r = e.m00 * this.m01 + e.m01 * this.m11 + e.m02 * this.m21, i = e.m00 * this.m02 + e.m01 * this.m12 + e.m02 * this.m22, s = e.m00 * this.m03 + e.m01 * this.m13 + e.m02 * this.m23 + e.m03, a = e.m10 * this.m00 + e.m11 * this.m10 + e.m12 * this.m20, o = e.m10 * this.m01 + e.m11 * this.m11 + e.m12 * this.m21, n = e.m10 * this.m02 + e.m11 * this.m12 + e.m12 * this.m22, h = e.m10 * this.m03 + e.m11 * this.m13 + e.m12 * this.m23 + e.m13, l = e.m20 * this.m00 + e.m21 * this.m10 + e.m22 * this.m20, f = e.m20 * this.m01 + e.m21 * this.m11 + e.m22 * this.m21, u = e.m20 * this.m02 + e.m21 * this.m12 + e.m22 * this.m22, d = e.m20 * this.m03 + e.m21 * this.m13 + e.m22 * this.m23 + e.m23;
this.m00 = t, this.m01 = r, this.m02 = i, this.m03 = s, this.m10 = a, this.m11 = o, 
this.m12 = n, this.m13 = h, this.m20 = l, this.m21 = f, this.m22 = u, this.m23 = d;
}, JSC3D.Math3D = {
transformVectors: function(e, t, r) {
for (var i = 0; i < t.length; i += 3) {
var s = t[i], a = t[i + 1], o = t[i + 2];
r[i] = e.m00 * s + e.m01 * a + e.m02 * o + e.m03, r[i + 1] = e.m10 * s + e.m11 * a + e.m12 * o + e.m13, 
r[i + 2] = e.m20 * s + e.m21 * a + e.m22 * o + e.m23;
}
},
transformVectorZs: function(e, t, r) {
for (var i = t.length / 3, s = 0, a = 0; s < i; ) r[s] = e.m20 * t[a] + e.m21 * t[a + 1] + e.m22 * t[a + 2] + e.m23, 
s++, a += 3;
},
normalizeVectors: function(e, t) {
for (var r = e.length, i = 0; i < r; i += 3) {
var s = e[i], a = e[i + 1], o = e[i + 2], n = Math.sqrt(s * s + a * a + o * o);
n > 0 && (s *= n = 1 / n, a *= n, o *= n), t[i] = s, t[i + 1] = a, t[i + 2] = o;
}
}
}, JSC3D.Util = {
ieXHRResponseBodyToString: function(e) {
for (var t = new VBArray(e).toArray(), r = "", i = 0; i < t.length - 65536; i += 65536) r += String.fromCharCode.apply(null, t.slice(i, i + 65536));
return r + String.fromCharCode.apply(null, t.slice(i));
}
}, JSC3D.PlatformInfo = {
browser: "other",
version: "n/a",
isTouchDevice: null != document.createTouch,
supportTypedArrays: null != window.Uint32Array,
supportWebGL: null != window.WebGLRenderingContext
}, JSC3D.BinaryStream = function(e, t) {
if (t) throw "JSC3D.BinaryStream constructor failed: Big endian is not supported yet!";
this.data = e, this.offset = 0;
}, JSC3D.BinaryStream.prototype.size = function() {
return this.data.length;
}, JSC3D.BinaryStream.prototype.tell = function() {
return this.offset;
}, JSC3D.BinaryStream.prototype.seek = function(e) {
return !(e < 0 || e >= this.data.length) && (this.offset = e, !0);
}, JSC3D.BinaryStream.prototype.reset = function() {
this.offset = 0;
}, JSC3D.BinaryStream.prototype.skip = function(e) {
this.offset + e > this.data.length ? this.offset = this.data.length : this.offset += e;
}, JSC3D.BinaryStream.prototype.available = function() {
return this.data.length - this.offset;
}, JSC3D.BinaryStream.prototype.eof = function() {
return !(this.offset < this.data.length);
}, JSC3D.BinaryStream.prototype.readUInt8 = function() {
return this.decodeInt(1, !1);
}, JSC3D.BinaryStream.prototype.readInt8 = function() {
return this.decodeInt(1, !0);
}, JSC3D.BinaryStream.prototype.readUInt16 = function() {
return this.decodeInt(2, !1);
}, JSC3D.BinaryStream.prototype.readInt16 = function() {
return this.decodeInt(2, !0);
}, JSC3D.BinaryStream.prototype.readUInt32 = function() {
return this.decodeInt(4, !1);
}, JSC3D.BinaryStream.prototype.readInt32 = function() {
return this.decodeInt(4, !0);
}, JSC3D.BinaryStream.prototype.readFloat32 = function() {
return this.decodeFloat(4, 23);
}, JSC3D.BinaryStream.prototype.readFloat64 = function() {
return this.decodeFloat(8, 52);
}, JSC3D.BinaryStream.prototype.readBytes = function(e, t) {
var r = t;
this.offset + t > this.data.length && (r = this.data.length - this.offset);
for (var i = 0; i < r; i++) e[i] = 255 & this.data[this.offset++].charCodeAt(0);
return r;
}, JSC3D.BinaryStream.prototype.decodeInt = function(e, t) {
if (this.offset + e > this.data.length) return this.offset = this.data.length, NaN;
for (var r = 0, i = 1, s = 0; s < e; s++) r += (255 & this.data[this.offset++].charCodeAt(0)) * i, 
i *= 256;
return t && r & Math.pow(2, 8 * e - 1) && (r -= Math.pow(2, 8 * e)), r;
}, JSC3D.BinaryStream.prototype.decodeFloat = function(e, t) {
if (this.offset + e > this.data.length) return this.offset = this.data.length, NaN;
var r = t, i = 8 * e - r - 1, s = (1 << i) - 1, a = s >> 1, o = e - 1, n = 255 & this.data[this.offset + o].charCodeAt(0);
o += -1;
var h = -7, l = n & (1 << -h) - 1;
for (n >>= -h, h += i; h > 0; ) l = 256 * l + (255 & this.data[this.offset + o].charCodeAt(0)), 
o += -1, h -= 8;
var f = l & (1 << -h) - 1;
for (l >>= -h, h += r; h > 0; ) f = 256 * f + (255 & this.data[this.offset + o].charCodeAt(0)), 
o += -1, h -= 8;
switch (this.offset += e, l) {
case 0:
l = 1 - a;
break;

case s:
return f ? NaN : 1 / 0 * (n ? -1 : 1);

default:
f += Math.pow(2, r), l -= a;
}
return (n ? -1 : 1) * f * Math.pow(2, l - r);
}, JSC3D.LoaderSelector = {
registerLoader: function(e, t) {
"function" == typeof t && (JSC3D.LoaderSelector.loaderTable[e] = t);
},
getLoader: function(e) {
var t, r = JSC3D.LoaderSelector.loaderTable[e.toLowerCase()];
if (!r) return null;
try {
t = new r();
} catch (e) {
t = null;
}
return t;
},
loaderTable: {}
}, JSC3D.ObjLoader = function(e, t, r, i) {
this.onload = e && "function" == typeof e ? e : null, this.onerror = t && "function" == typeof t ? t : null, 
this.onprogress = r && "function" == typeof r ? r : null, this.onresource = i && "function" == typeof i ? i : null, 
this.requestCount = 0, this.requests = [];
}, JSC3D.ObjLoader.prototype.loadFromUrl = function(e) {
var t = "", r = e, i = "", s = e.indexOf("?");
s >= 0 && (i = e.substring(s), r = e = e.substring(0, s));
var a = e.lastIndexOf("/");
-1 == a && (a = e.lastIndexOf("\\")), -1 != a && (t = e.substring(0, a + 1), r = e.substring(a + 1)), 
this.requestCount = 0, this.loadObjFile(t, r, i);
}, JSC3D.ObjLoader.prototype.abort = function() {
for (var e = 0; e < this.requests.length; e++) this.requests[e].abort();
this.requests = [], this.requestCount = 0;
}, JSC3D.ObjLoader.prototype.loadObjFile = function(e, t, r) {
var i = e + t + r, s = this, a = new XMLHttpRequest();
a.open("GET", encodeURI(i), !0), a.onreadystatechange = function() {
if (4 == this.readyState) if (200 == this.status || 0 == this.status) {
if (s.onload) {
s.onprogress && s.onprogress("Loading obj file ...", 1), JSC3D.console && JSC3D.console.logInfo('Finished loading obj file "' + i + '".');
var t = new JSC3D.Scene();
t.srcUrl = i;
var r = s.parseObj(t, this.responseText);
if (r.length > 0) for (var a = 0; a < r.length; a++) s.loadMtlFile(t, e, r[a]);
s.requests.splice(s.requests.indexOf(this), 1), 0 == --s.requestCount && s.onload(t);
}
} else s.requests.splice(s.requests.indexOf(this), 1), s.requestCount--, JSC3D.console && JSC3D.console.logError('Failed to load obj file "' + i + '".'), 
s.onerror && s.onerror('Failed to load obj file "' + i + '".');
}, this.onprogress && (this.onprogress("Loading obj file ...", 0), a.onprogress = function(e) {
s.onprogress("Loading obj file ...", e.position / e.totalSize);
}), this.requests.push(a), this.requestCount++, a.send();
}, JSC3D.ObjLoader.prototype.loadMtlFile = function(e, t, r) {
var i = t + r, s = this, a = new XMLHttpRequest();
a.open("GET", encodeURI(i), !0), a.onreadystatechange = function() {
if (4 == this.readyState) {
if (200 == this.status || 0 == this.status) {
s.onprogress && s.onprogress("Loading mtl file ...", 1), JSC3D.console && JSC3D.console.logInfo('Finished loading mtl file "' + i + '".');
for (var a = s.parseMtl(this.responseText), o = {}, n = e.getChildren(), h = 0; h < n.length; h++) {
var l = n[h];
if (null != l.mtl && null != l.mtllib && l.mtllib == r) {
var f = a[l.mtl];
null != f && (null != f.material && l.setMaterial(f.material), "" != f.textureFileName && (o[f.textureFileName] ? o[f.textureFileName].push(l) : o[f.textureFileName] = [ l ]));
}
}
for (var u in o) s.setupTexture(o[u], t + u);
} else JSC3D.console && JSC3D.console.logWarning('Failed to load mtl file "' + i + '". A default material will be applied.');
s.requests.splice(s.requests.indexOf(this), 1), 0 == --s.requestCount && s.onload(e);
}
}, this.onprogress && (this.onprogress("Loading mtl file ...", 0), a.onprogress = function(e) {
s.onprogress("Loading mtl file ...", e.position / e.totalSize);
}), this.requests.push(a), this.requestCount++, a.send();
}, JSC3D.ObjLoader.prototype.parseObj = function(e, t) {
var r = {}, i = [], s = 0, a = null, o = "", n = "", h = [], l = [], f = "obj-" + s++, u = new JSC3D.Mesh();
u.name = f, u.indexBuffer = [], r.nomtl = u, a = u;
for (var d = t.split(/[ \t]*\r?\n[ \t]*/), p = 0; p < d.length; p++) {
var m = d[p].split(/[ \t]+/);
if (m.length > 0) switch (m[0]) {
case "v":
if (m.length > 3) for (var c = 1; c < 4; c++) h.push(parseFloat(m[c]));
break;

case "vn":
break;

case "vt":
m.length > 2 && (l.push(parseFloat(m[1])), l.push(1 - parseFloat(m[2])));
break;

case "f":
if (m.length > 3) {
for (c = 1; c < m.length; c++) {
var g = m[c].split("/"), C = parseInt(g[0]) - 1;
a.indexBuffer.push(C), g.length > 1 && ("" != g[1] ? (a.texCoordIndexBuffer || (a.texCoordIndexBuffer = []), 
a.texCoordIndexBuffer.push(parseInt(g[1]) - 1)) : (g.length < 3 || "" == g[2]) && (a.texCoordIndexBuffer || (a.texCoordIndexBuffer = []), 
a.texCoordIndexBuffer.push(C)));
}
a.indexBuffer.push(-1), a.texCoordIndexBuffer && a.texCoordIndexBuffer.push(-1);
}
break;

case "mtllib":
m.length > 1 ? (o = m[1], i.push(o)) : o = "";
break;

case "usemtl":
if (m.length > 1 && "" != m[1] && "" != o) {
var y = o + "-" + (n = m[1]);
(v = r[y]) || ((v = new JSC3D.Mesh()).name = "obj-" + s++, v.indexBuffer = [], v.mtllib = o, 
v.mtl = n, r[y] = v), a = v;
} else n = "", a = u;
}
}
var S = h.length >= 3 ? new Array(h.length / 3) : null, x = l.length >= 2 ? new Array(l.length / 2) : null;
for (var D in r) {
var v = r[D];
if (h.length >= 3 && v.indexBuffer.length > 0) {
for (p = 0; p < S.length; p++) S[p] = -1;
v.vertexBuffer = [];
var w = 0, b = 0;
for (p = 0; p < v.indexBuffer.length; p++) if (-1 != (w = v.indexBuffer[p])) if (-1 == S[w]) {
var B = 3 * w;
v.vertexBuffer.push(h[B]), v.vertexBuffer.push(h[B + 1]), v.vertexBuffer.push(h[B + 2]), 
v.indexBuffer[p] = b, S[w] = b, b++;
} else v.indexBuffer[p] = S[w];
}
if (l.length >= 2 && null != v.texCoordIndexBuffer && v.texCoordIndexBuffer.length > 0) {
for (p = 0; p < x.length; p++) x[p] = -1;
v.texCoordBuffer = [];
var J = 0, M = 0;
for (p = 0; p < v.texCoordIndexBuffer.length; p++) if (-1 != (J = v.texCoordIndexBuffer[p])) if (-1 == x[J]) {
var k = 2 * J;
v.texCoordBuffer.push(l[k]), v.texCoordBuffer.push(l[k + 1]), v.texCoordIndexBuffer[p] = M, 
x[J] = M, M++;
} else v.texCoordIndexBuffer[p] = x[J];
}
v.isTrivial() || e.addChild(v);
}
return i;
}, JSC3D.ObjLoader.prototype.parseMtl = function(e) {
for (var t = {}, r = "", i = e.split(/[ \t]*\r?\n[ \t]*/), s = 0; s < i.length; s++) {
var a = i[s].split(/[ \t]+/);
if (a.length > 0) switch (a[0]) {
case "newmtl":
r = a[1], (f = {}).material = new JSC3D.Material(), f.material.name = r, f.textureFileName = "", 
t[r] = f;
break;

case "Ka":
case "ka":
break;

case "Kd":
case "kd":
if (4 == a.length && !isNaN(a[1])) {
var o = 255 * parseFloat(a[1]) & 255, n = 255 * parseFloat(a[2]) & 255, h = 255 * parseFloat(a[3]) & 255;
null != (f = t[r]) && (f.material.diffuseColor = o << 16 | n << 8 | h);
}
break;

case "Ks":
case "ks":
break;

case "d":
if (2 == a.length && !isNaN(a[1])) {
var l = parseFloat(a[1]);
null != (f = t[r]) && (f.material.transparency = 1 - l);
}
break;

case "illum":
break;

case "map_Kd":
case "map_kd":
if (2 == a.length) {
var f, u = a[1];
null != (f = t[r]) && (f.textureFileName = u);
}
}
}
return t;
}, JSC3D.ObjLoader.prototype.setupTexture = function(e, t) {
var r = this, i = new JSC3D.Texture();
i.onready = function() {
for (var t = 0; t < e.length; t++) e[t].setTexture(this);
r.onresource && r.onresource(this);
}, i.createFromUrl(t);
}, JSC3D.ObjLoader.prototype.onload = null, JSC3D.ObjLoader.prototype.onerror = null, 
JSC3D.ObjLoader.prototype.onprogress = null, JSC3D.ObjLoader.prototype.onresource = null, 
JSC3D.ObjLoader.prototype.requestCount = 0, JSC3D.LoaderSelector.registerLoader("obj", JSC3D.ObjLoader), 
JSC3D.StlLoader = function(e, t, r, i) {
this.onload = e && "function" == typeof e ? e : null, this.onerror = t && "function" == typeof t ? t : null, 
this.onprogress = r && "function" == typeof r ? r : null, this.onresource = i && "function" == typeof i ? i : null, 
this.decimalPrecision = 3, this.request = null;
}, JSC3D.StlLoader.prototype.loadFromUrl = function(e) {
var t = this, r = "ie" == JSC3D.PlatformInfo.browser, i = new XMLHttpRequest();
i.open("GET", encodeURI(e), !0), r ? i.setRequestHeader("Accept-Charset", "x-user-defined") : i.overrideMimeType("text/plain; charset=x-user-defined"), 
i.onreadystatechange = function() {
if (4 == this.readyState) {
if (200 == this.status || 0 == this.status) {
if (JSC3D.console && JSC3D.console.logInfo('Finished loading STL file "' + e + '".'), 
t.onload) if (t.onprogress && t.onprogress("Loading STL file ...", 1), r) {
(i = new JSC3D.Scene()).srcUrl = e;
try {
t.parseStl(i, JSC3D.Util.ieXHRResponseBodyToString(this.responseBody));
} catch (e) {}
t.onload(i);
} else {
var i;
(i = new JSC3D.Scene()).srcUrl = e, t.parseStl(i, this.responseText), t.onload(i);
}
} else JSC3D.console && JSC3D.console.logError('Failed to load STL file "' + e + '".'), 
t.onerror && t.onerror('Failed to load STL file "' + e + '".');
t.request = null;
}
}, this.onprogress && (this.onprogress("Loading STL file ...", 0), i.onprogress = function(e) {
t.onprogress("Loading STL file ...", e.position / e.totalSize);
}), this.request = i, i.send();
}, JSC3D.StlLoader.prototype.abort = function() {
this.request && (this.request.abort(), this.request = null);
}, JSC3D.StlLoader.prototype.setDecimalPrecision = function(e) {
this.decimalPrecision = e;
}, JSC3D.StlLoader.prototype.parseStl = function(e, t) {
var r = new JSC3D.Mesh();
r.vertexBuffer = [], r.indexBuffer = [], r.faceNormalBuffer = [];
var i = !1, s = new JSC3D.BinaryStream(t);
s.skip(84);
for (var a = 0; a < 256 && !s.eof(); a++) if (s.readUInt8() > 127) {
i = !0;
break;
}
if (JSC3D.console && JSC3D.console.logInfo("This is recognised as " + (i ? "a binary" : "an ASCII") + " STL file."), 
i) {
s.reset(), s.skip(80);
var o = 84 + 50 * (f = s.readUInt32());
if (s.size() < o) return void (JSC3D.console && JSC3D.console.logError("Failed to parse contents of the file. It seems not complete."));
r.faceCount = f;
for (u = {}, a = 0; a < f; a++) {
r.faceNormalBuffer.push(s.readFloat32()), r.faceNormalBuffer.push(s.readFloat32()), 
r.faceNormalBuffer.push(s.readFloat32());
for (var n = 0; n < 3; n++) {
c = s.readFloat32(), g = s.readFloat32(), C = s.readFloat32(), null != (m = u[p = c.toFixed(this.decimalPrecision) + "-" + g.toFixed(this.decimalPrecision) + "-" + C.toFixed(this.decimalPrecision)]) || (m = r.vertexBuffer.length / 3, 
u[p] = m, r.vertexBuffer.push(c), r.vertexBuffer.push(g), r.vertexBuffer.push(C)), 
r.indexBuffer.push(m);
}
r.indexBuffer.push(-1), s.skip(2);
}
} else {
var h = new RegExp("facet\\s+normal\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+outer\\s+loop\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+endloop\\s+endfacet", "ig"), l = t.match(h);
if (l) {
var f = l.length;
r.faceCount = f;
var u = {};
h.lastIndex = 0, h.global = !1;
for (var d = h.exec(t); null != d; d = h.exec(t)) {
r.faceNormalBuffer.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]));
for (var a = 0; a < 3; a++) {
var p, m, c = parseFloat(d[4 + 3 * a]), g = parseFloat(d[5 + 3 * a]), C = parseFloat(d[6 + 3 * a]);
void 0 === (m = u[p = c.toFixed(this.decimalPrecision) + "-" + g.toFixed(this.decimalPrecision) + "-" + C.toFixed(this.decimalPrecision)]) && (m = r.vertexBuffer.length / 3, 
u[p] = m, r.vertexBuffer.push(c), r.vertexBuffer.push(g), r.vertexBuffer.push(C)), 
r.indexBuffer.push(m);
}
r.indexBuffer.push(-1);
}
}
}
r.isTrivial() || (Math.abs(r.faceNormalBuffer[0]) < 1e-6 && Math.abs(r.faceNormalBuffer[1]) < 1e-6 && Math.abs(r.faceNormalBuffer[2]) < 1e-6 && (r.faceNormalBuffer = null), 
e.addChild(r));
}, JSC3D.StlLoader.prototype.onload = null, JSC3D.StlLoader.prototype.onerror = null, 
JSC3D.StlLoader.prototype.onprogress = null, JSC3D.StlLoader.prototype.onresource = null, 
JSC3D.StlLoader.prototype.decimalPrecision = 3, JSC3D.LoaderSelector.registerLoader("stl", JSC3D.StlLoader);
export default JSC3D;
